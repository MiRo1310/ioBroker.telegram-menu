{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["'use strict';\n/*\n * Created with @iobroker/create-adapter v2.3.0\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from '@iobroker/adapter-core';\n\nimport { checkEvent, generateActions, getUserToSendFromUserListWithChatID } from './app/action.js';\nimport { _subscribeForeignStates } from './app/subscribeStates.js';\nimport { sendToTelegram } from './app/telegram.js';\nimport { createState } from './app/createState.js';\nimport { saveMessageIds } from './app/messageIds.js';\nimport { adapterStartMenuSend } from './app/adapterStartMenuSend.js';\nimport { checkEveryMenuForData, getTimeouts } from './app/processData.js';\nimport { deleteMessageAndSendNewShoppingList, shoppingListSubscribeStateAndDeleteItem } from './app/shoppingList.js';\nimport { errorLogger } from './app/logging.js';\nimport type { MenuData, SetStateIds, TelegramParams } from './types/types';\nimport { areAllCheckTelegramInstancesActive } from './app/connection.js';\nimport { decomposeText, isString, jsonString } from './lib/string';\nimport { isDefined, isFalsy, isTruthy } from './lib/utils';\nimport {\n    getInstanceById,\n    getListOfMenusIncludingUser,\n    getNewStructure,\n    getStartSides,\n    splitNavigation,\n} from './lib/appUtils';\nimport { getConfigVariables, getIds } from './app/configVariables';\nimport { getStateIdsToListenTo } from './app/setStateIdsToListenTo';\nimport type { UserListWithChatID } from '@/types/app';\nimport { exchangePlaceholderWithValue, exchangeValue } from './lib/exchangeValue';\n\nconst timeoutKey = '0';\nexport let adapter: TelegramMenu;\n\nexport default class TelegramMenu extends utils.Adapter {\n    private static instance: TelegramMenu;\n\n    /**\n     * @param [options] - Adapter options\n     */\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'telegram-menu',\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n        TelegramMenu.instance = this;\n    }\n\n    private async onReady(): Promise<void> {\n        adapter = this;\n        await this.setState('info.connection', false, true);\n        await createState(this);\n\n        const {\n            directoryPicture,\n            telegramParams,\n            menusWithUsers,\n            listOfMenus,\n            isUserActiveCheckbox,\n            checkboxNoEntryFound,\n            textNoEntryFound,\n            sendMenuAfterRestart,\n            token,\n            dataObject,\n            checkboxes,\n        } = getConfigVariables(this.config);\n        const {\n            telegramBotSendMessageID,\n            telegramRequestID,\n            telegramRequestMessageID,\n            telegramRequestChatID,\n            telegramInfoConnectionID,\n        } = getIds;\n\n        const menuData: MenuData = {};\n        const startSides = getStartSides(menusWithUsers, dataObject);\n        try {\n            if (!(await areAllCheckTelegramInstancesActive(telegramParams))) {\n                this.log.error('Not all Telegram instances are active. Please check your configuration.');\n                return;\n            }\n\n            const { nav, action } = dataObject;\n\n            this.log.info('Telegram was found');\n\n            for (const name in nav) {\n                const splittedNavigation = splitNavigation(nav[name]);\n                const newStructure = getNewStructure(splittedNavigation);\n                const generatedActions = generateActions({ action: action?.[name], userObject: newStructure });\n\n                menuData[name] = newStructure;\n                if (generatedActions) {\n                    menuData[name] = generatedActions?.obj;\n                    const subscribeForeignStateIds = generatedActions?.ids;\n                    if (subscribeForeignStateIds?.length) {\n                        await _subscribeForeignStates(subscribeForeignStateIds);\n                    }\n                } else {\n                    adapter.log.debug('No Actions generated!');\n                }\n\n                // Subscribe Events\n                const events = dataObject.action?.[name]?.events;\n                if (events) {\n                    for (const event of events) {\n                        await _subscribeForeignStates(event.ID);\n                    }\n                }\n                adapter.log.debug(`Menu: ${name}`);\n                adapter.log.debug(`Array Buttons: ${jsonString(splittedNavigation)}`);\n                adapter.log.debug(`Gen. Actions: ${jsonString(menuData[name])}`);\n            }\n\n            adapter.log.debug(`Checkbox: ${jsonString(checkboxes)}`);\n            adapter.log.debug(`MenuList: ${jsonString(listOfMenus)}`);\n\n            if (sendMenuAfterRestart) {\n                await adapterStartMenuSend(\n                    listOfMenus,\n                    startSides,\n                    isUserActiveCheckbox,\n                    menusWithUsers,\n                    menuData,\n                    telegramParams,\n                );\n            }\n            let menus: string[] = [];\n            this.on('stateChange', async (id, state) => {\n                const setStateIdsToListenTo: SetStateIds[] = getStateIdsToListenTo();\n                const instance = await this.checkInfoConnection(id, telegramParams);\n                if (!instance) {\n                    return;\n                }\n\n                const { userToSend, error } = await this.getChatIDAndUserToSend(telegramParams, instance);\n\n                if (error) {\n                    return;\n                }\n\n                if (this.isAddToShoppingList(id, userToSend.name)) {\n                    await deleteMessageAndSendNewShoppingList(instance, telegramParams, userToSend.name);\n                    return;\n                }\n\n                if (!state || !isDefined(state.val)) {\n                    return;\n                }\n\n                if (isString(state.val) && state.val?.includes('sList:')) {\n                    await shoppingListSubscribeStateAndDeleteItem(instance, state.val, telegramParams);\n                    return;\n                }\n\n                if (await checkEvent(instance, dataObject, id, state, menuData, telegramParams, menusWithUsers)) {\n                    return;\n                }\n\n                if (this.isMessageID(id, telegramBotSendMessageID(instance), telegramRequestMessageID(instance))) {\n                    await saveMessageIds(state, instance);\n                } else if (this.isMenuToSend(state, id, telegramRequestID(instance), userToSend.name)) {\n                    const value = state.val.toString();\n\n                    const calledValue = value.slice(value.indexOf(']') + 1, value.length);\n                    menus = getListOfMenusIncludingUser(menusWithUsers, userToSend.name);\n\n                    const dataFound = await checkEveryMenuForData({\n                        instance,\n                        menuData,\n                        navToGoTo: calledValue,\n                        userToSend: userToSend.name,\n                        telegramParams,\n                        menus,\n                        isUserActiveCheckbox,\n                        token,\n                        directoryPicture,\n                        timeoutKey,\n                    });\n\n                    this.log.debug(`Groups with searched User: ${jsonString(menus)}`);\n\n                    if (!dataFound && checkboxNoEntryFound) {\n                        adapter.log.debug('No Entry found');\n                        await sendToTelegram({\n                            instance: instance,\n                            userToSend: userToSend.name,\n                            textToSend: textNoEntryFound,\n                            telegramParams,\n                        });\n                    }\n                    return;\n                }\n                if (state && setStateIdsToListenTo?.find(element => element.id == id)) {\n                    adapter.log.debug(`Subscribed state changed: { id : ${id} , state : ${jsonString(state)} }`);\n\n                    for (const el of setStateIdsToListenTo) {\n                        const { id: elId, userToSend, confirm, returnText, parse_mode } = el;\n                        const key: number = setStateIdsToListenTo.indexOf(el);\n\n                        if (elId == id) {\n                            adapter.log.debug(`Send Value: ${jsonString(el)}`);\n                            adapter.log.debug(`State: ${jsonString(state)}`);\n\n                            if (isTruthy(confirm) && !state?.ack && returnText?.includes('{confirmSet:')) {\n                                const { substring } = decomposeText(returnText, '{confirmSet:', '}');\n                                const splitSubstring = substring.split(':');\n\n                                let text = '';\n                                if (isDefined(state.val)) {\n                                    text = splitSubstring[2]?.includes('noValue')\n                                        ? splitSubstring[1]\n                                        : exchangePlaceholderWithValue(splitSubstring[1], state.val.toString());\n                                }\n                                adapter.log.debug(`Return-text: ${text}`);\n\n                                if (text === '') {\n                                    adapter.log.error('The return text cannot be empty, please check.');\n                                }\n\n                                await sendToTelegram({\n                                    instance: instance,\n                                    textToSend: text,\n                                    parse_mode: parse_mode,\n                                    userToSend,\n                                    telegramParams,\n                                });\n                                continue;\n                            }\n                            adapter.log.debug(`Data: ${jsonString({ confirm, ack: state?.ack, val: state?.val })}`);\n\n                            if (!isFalsy(confirm) && state?.ack) {\n                                let textToSend = returnText;\n\n                                if (textToSend?.includes('{confirmSet:')) {\n                                    textToSend = decomposeText(textToSend, '{confirmSet:', '}').textExcludeSubstring;\n                                }\n\n                                if (textToSend?.includes('{setDynamicValue')) {\n                                    const { textExcludeSubstring, substringExcludeSearch } = decomposeText(\n                                        textToSend,\n                                        '{setDynamicValue:',\n                                        '}',\n                                    );\n                                    const splitSubstring = substringExcludeSearch.split(':');\n                                    const confirmText = splitSubstring[2];\n                                    textToSend = `${textExcludeSubstring} ${confirmText}`;\n                                }\n\n                                const {\n                                    textToSend: changedText,\n                                    error,\n                                    newValue,\n                                } = exchangeValue(adapter, textToSend ?? '', state.val?.toString());\n\n                                if (!error) {\n                                    textToSend = changedText;\n                                }\n\n                                adapter.log.debug(`Value to send: ${newValue}`);\n\n                                await sendToTelegram({\n                                    instance: instance,\n                                    userToSend,\n                                    textToSend,\n                                    parse_mode,\n                                    telegramParams,\n                                });\n                                setStateIdsToListenTo.splice(key, 1);\n                            }\n                        }\n                    }\n                }\n            });\n        } catch (e: any) {\n            errorLogger('Error onReady', e, adapter);\n        }\n\n        for (const instance of telegramParams.telegramInstanceList) {\n            const instanceName = instance.name;\n            if (!instance.active || !instanceName) {\n                continue;\n            }\n            this.log.debug(`Subscribe to instance: ${instanceName}`);\n            await this.subscribeForeignStatesAsync(telegramBotSendMessageID(instanceName));\n            await this.subscribeForeignStatesAsync(telegramRequestMessageID(instanceName));\n            await this.subscribeForeignStatesAsync(telegramRequestChatID(instanceName));\n            await this.subscribeForeignStatesAsync(telegramRequestID(instanceName));\n            await this.subscribeForeignStatesAsync(telegramInfoConnectionID(instanceName));\n        }\n    }\n\n    private isMessageID(id: string, botSendMessageID: string, requestMessageID: string): boolean {\n        return id == botSendMessageID || id == requestMessageID;\n    }\n\n    private isAddToShoppingList(id: string, userToSend: string): boolean {\n        return !!(id.includes('alexa-shoppinglist') && !id.includes('add_position') && userToSend);\n    }\n\n    private isMenuToSend(\n        state: ioBroker.State | null | undefined,\n        id: string,\n        telegramID: string,\n        userToSend: string | null,\n    ): boolean {\n        return !!(typeof state?.val === 'string' && state.val != '' && id == telegramID && state?.ack && userToSend);\n    }\n\n    private async checkInfoConnection(id: string, telegramParams: TelegramParams): Promise<string | null> {\n        try {\n            const { telegramInfoConnectionID } = getIds;\n            const { instance } = getInstanceById(id);\n            const instanceObj = telegramParams.telegramInstanceList.find(item => item.name === instance);\n            const iterationId = telegramInfoConnectionID(instance);\n            if (instanceObj?.active) {\n                const active = await this.isTelegramInstanceActive(iterationId);\n                if (active) {\n                    return instance;\n                }\n            }\n\n            return null;\n        } catch (e) {\n            errorLogger('Error checkInfoConnection', e, adapter);\n            return null;\n        }\n    }\n\n    private async isTelegramInstanceActive(id: string): Promise<boolean> {\n        if (!(await adapter.getForeignStateAsync(id))) {\n            this.log.debug('Telegram is not active');\n            return false;\n        }\n        return true;\n    }\n\n    private async getChatIDAndUserToSend(\n        telegramParams: TelegramParams,\n        telegramInstance: string,\n    ): Promise<{ chatID: string; userToSend: UserListWithChatID; error: boolean; errorMessage?: string }> {\n        const { userListWithChatID } = telegramParams;\n        const chatIDState = await this.getForeignStateAsync(`${telegramInstance}.communicate.requestChatId`);\n\n        if (!chatIDState?.val) {\n            adapter.log.debug('ChatID not found');\n            return { chatID: '', userToSend: {} as UserListWithChatID, error: true, errorMessage: 'ChatId not found' };\n        }\n\n        const userToSend = getUserToSendFromUserListWithChatID(userListWithChatID, chatIDState.val.toString());\n        if (!userToSend) {\n            this.log.debug('User to send not found');\n            return {\n                chatID: chatIDState.val.toString(),\n                userToSend: {} as UserListWithChatID,\n                error: true,\n                errorMessage: 'User not found',\n            };\n        }\n        return { chatID: chatIDState.val.toString(), userToSend, error: false };\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     *\n     * @param callback - Is called when adapter has closed all connections and released all resources\n     */\n    private onUnload(callback: () => void): void {\n        const timeouts = getTimeouts();\n        try {\n            // Here you must clear all timeouts or intervals that may still be active\n            timeouts.forEach(({ timeout }) => {\n                adapter.clearTimeout(timeout);\n            });\n\n            callback();\n        } catch (e: any) {\n            errorLogger(e, 'Error onUnload', adapter);\n            callback();\n        }\n    }\n\n    onMessage(obj: ioBroker.Message): void {\n        if (typeof obj === 'object' && obj.message) {\n            if (obj.command === 'send') {\n                // e.g. send email or pushover or whatever\n                this.log.info('send command');\n                // Send response in callback if required\n                if (obj.callback) {\n                    this.sendTo(obj.from, obj.command, 'Message received', obj.callback);\n                }\n            }\n        }\n    }\n}\n\nexport const createTelegramMenu = (options?: Partial<utils.AdapterOptions<undefined, undefined>>): TelegramMenu =>\n    new TelegramMenu(options);\n\nif (require.main === module) {\n    (() => new TelegramMenu())();\n}\n"],
  "mappings": "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",
  "names": ["_a", "_b", "userToSend", "error"]
}

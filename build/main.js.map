{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["'use strict';\n/*\n * Created with @iobroker/create-adapter v2.3.0\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from '@iobroker/adapter-core';\n\nimport { checkEvent, generateActions, getUserToSendFromUserListWithChatID } from './app/action.js';\nimport { _subscribeForeignStates } from './app/subscribeStates.js';\nimport { sendToTelegram } from './app/telegram.js';\nimport { createState } from './app/createState.js';\nimport { saveMessageIds } from './app/messageIds.js';\nimport { adapterStartMenuSend } from './app/adapterStartMenuSend.js';\nimport { checkEveryMenuForData, getTimeouts } from './app/processData.js';\nimport { deleteMessageAndSendNewShoppingList, shoppingListSubscribeStateAndDeleteItem } from './app/shoppingList.js';\nimport { errorLogger } from './app/logging.js';\nimport type { MenuData, SetStateIds, TelegramParams } from './types/types';\nimport { checkIsTelegramActive } from './app/connection.js';\nimport { decomposeText, isString, jsonString } from './lib/string';\nimport { isDefined, isFalsy, isTruthy } from './lib/utils';\nimport { getListOfMenusIncludingUser, getNewStructure, getStartSides, splitNavigation } from './lib/appUtils';\nimport { getConfigVariables } from './app/configVariables';\nimport { getStateIdsToListenTo } from './app/setStateIdsToListenTo';\nimport { exchangePlaceholderWithValue, exchangeValue } from './lib/exchangeValue';\n\nconst timeoutKey = '0';\nexport let adapter: TelegramMenu;\n\nexport default class TelegramMenu extends utils.Adapter {\n    private static instance: TelegramMenu;\n\n    /**\n     * @param [options] - Adapter options\n     */\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'telegram-menu',\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n        TelegramMenu.instance = this;\n    }\n\n    private async onReady(): Promise<void> {\n        adapter = this;\n        await this.setState('info.connection', false, true);\n        await createState(this);\n\n        const {\n            requestMessageID,\n            directoryPicture,\n            telegramParams,\n            telegramID,\n            menusWithUsers,\n            infoConnectionOfTelegram,\n            listOfMenus,\n            isUserActiveCheckbox,\n            checkboxNoEntryFound,\n            textNoEntryFound,\n            botSendMessageID,\n            sendMenuAfterRestart,\n            token,\n            dataObject,\n            checkboxes,\n        } = getConfigVariables(this.config);\n        const { telegramInstance } = telegramParams;\n\n        const menuData: MenuData = {};\n        const startSides = getStartSides(menusWithUsers, dataObject);\n        try {\n            await this.getForeignObject(infoConnectionOfTelegram, async (err, obj) => {\n                if (err || !obj) {\n                    this.log.error(`The State ${infoConnectionOfTelegram} was not found! ${err}`);\n                    return;\n                }\n\n                if (!(await checkIsTelegramActive(infoConnectionOfTelegram))) {\n                    return;\n                }\n\n                const { nav, action } = dataObject;\n\n                this.log.info('Telegram was found');\n\n                for (const name in nav) {\n                    const splittedNavigation = splitNavigation(nav[name]);\n                    const newStructure = getNewStructure(splittedNavigation);\n                    const generatedActions = generateActions({ action: action?.[name], userObject: newStructure });\n\n                    menuData[name] = newStructure;\n                    if (generatedActions) {\n                        menuData[name] = generatedActions?.obj;\n                        const subscribeForeignStateIds = generatedActions?.ids;\n                        if (subscribeForeignStateIds?.length) {\n                            await _subscribeForeignStates(subscribeForeignStateIds);\n                        }\n                    } else {\n                        adapter.log.debug('No Actions generated!');\n                    }\n\n                    // Subscribe Events\n                    if (dataObject.action?.[name]?.events) {\n                        for (const event of dataObject.action[name].events) {\n                            await _subscribeForeignStates(event.ID);\n                        }\n                    }\n                    adapter.log.debug(`Menu: ${name}`);\n                    adapter.log.debug(`Array Buttons: ${jsonString(splittedNavigation)}`);\n                    adapter.log.debug(`Gen. Actions: ${jsonString(menuData[name])}`);\n                }\n\n                adapter.log.debug(`Checkbox: ${jsonString(checkboxes)}`);\n                adapter.log.debug(`MenuList: ${jsonString(listOfMenus)}`);\n\n                if (sendMenuAfterRestart) {\n                    await adapterStartMenuSend(\n                        listOfMenus,\n                        startSides,\n                        isUserActiveCheckbox,\n                        menusWithUsers,\n                        menuData,\n                        telegramParams,\n                    );\n                }\n\n                this.on('stateChange', async (id, state) => {\n                    const setStateIdsToListenTo: SetStateIds[] = getStateIdsToListenTo();\n\n                    const isTelegramInstanceActive = await this.checkInfoConnection(id, infoConnectionOfTelegram);\n                    if (!isTelegramInstanceActive) {\n                        return;\n                    }\n\n                    const { userToSend, error } = await this.getChatIDAndUserToSend(telegramParams);\n                    if (error) {\n                        return;\n                    }\n\n                    if (this.isAddToShoppingList(id, userToSend)) {\n                        await deleteMessageAndSendNewShoppingList(telegramParams, userToSend);\n                        return;\n                    }\n\n                    if (!state || !isDefined(state.val)) {\n                        return;\n                    }\n\n                    if (isString(state.val) && state.val.includes('sList:')) {\n                        await shoppingListSubscribeStateAndDeleteItem(state.val, telegramParams);\n                        return;\n                    }\n\n                    if (await checkEvent(dataObject, id, state, menuData, telegramParams, menusWithUsers)) {\n                        return;\n                    }\n\n                    if (this.isMessageID(id, botSendMessageID, requestMessageID)) {\n                        await saveMessageIds(state, telegramInstance);\n                    } else if (this.isMenuToSend(state, id, telegramID, userToSend)) {\n                        const value = state.val.toString();\n\n                        const calledValue = value.slice(value.indexOf(']') + 1, value.length);\n                        const menus = getListOfMenusIncludingUser(menusWithUsers, userToSend);\n\n                        const dataFound = await checkEveryMenuForData({\n                            menuData,\n                            calledValue,\n                            userToSend,\n                            telegramParams,\n                            menus,\n                            isUserActiveCheckbox,\n                            token,\n                            directoryPicture,\n                            timeoutKey,\n                        });\n\n                        this.log.debug(`Groups with searched User: ${jsonString(menus)}`);\n\n                        if (!dataFound && checkboxNoEntryFound) {\n                            adapter.log.debug('No Entry found');\n                            await sendToTelegram({\n                                userToSend,\n                                textToSend: textNoEntryFound,\n                                telegramParams,\n                            });\n                        }\n                        return;\n                    }\n                    if (state && setStateIdsToListenTo?.find(element => element.id == id)) {\n                        adapter.log.debug(`Subscribed state changed: { id : ${id} , state : ${jsonString(state)} }`);\n\n                        for (const el of setStateIdsToListenTo) {\n                            const { id: elId, userToSend, confirm, returnText, parse_mode } = el;\n                            const key: number = setStateIdsToListenTo.indexOf(el);\n\n                            if (elId == id) {\n                                adapter.log.debug(`Send Value: ${jsonString(el)}`);\n                                adapter.log.debug(`State: ${jsonString(state)}`);\n\n                                if (isTruthy(confirm) && !state?.ack && returnText.includes('{confirmSet:')) {\n                                    const { substring } = decomposeText(returnText, '{confirmSet:', '}');\n                                    const splitSubstring = substring.split(':');\n\n                                    let text = '';\n                                    if (isDefined(state.val)) {\n                                        text = splitSubstring[2]?.includes('noValue')\n                                            ? splitSubstring[1]\n                                            : exchangePlaceholderWithValue(splitSubstring[1], state.val.toString());\n                                    }\n                                    adapter.log.debug(`Return-text: ${text}`);\n\n                                    if (text === '') {\n                                        adapter.log.error('The return text cannot be empty, please check.');\n                                    }\n\n                                    await sendToTelegram({\n                                        textToSend: text,\n                                        parse_mode: parse_mode,\n                                        userToSend,\n                                        telegramParams,\n                                    });\n                                    continue;\n                                }\n                                adapter.log.debug(`Data: ${jsonString({ confirm, ack: state?.ack, val: state?.val })}`);\n\n                                if (!isFalsy(confirm) && state?.ack) {\n                                    let textToSend = returnText;\n\n                                    if (textToSend.includes('{confirmSet:')) {\n                                        const { textExcludeSubstring } = decomposeText(textToSend, '{confirmSet:', '}');\n                                        textToSend = textExcludeSubstring;\n                                    }\n\n                                    const {\n                                        textToSend: changedText,\n                                        error,\n                                        newValue,\n                                    } = exchangeValue(adapter, textToSend, state.val?.toString());\n\n                                    if (!error) {\n                                        textToSend = changedText;\n                                    }\n\n                                    adapter.log.debug(`Value to send: ${newValue}`);\n\n                                    await sendToTelegram({\n                                        userToSend,\n                                        textToSend,\n                                        parse_mode: parse_mode,\n                                        telegramParams,\n                                    });\n\n                                    setStateIdsToListenTo.splice(key, 1);\n                                }\n                            }\n                        }\n                    }\n                });\n            });\n        } catch (e: any) {\n            errorLogger('Error onReady', e, adapter);\n        }\n\n        await this.subscribeForeignStatesAsync(botSendMessageID);\n        await this.subscribeForeignStatesAsync(requestMessageID);\n        await this.subscribeForeignStatesAsync(`${telegramInstance}.communicate.requestChatId`);\n        await this.subscribeForeignStatesAsync(telegramID);\n        await this.subscribeForeignStatesAsync(`${telegramInstance}.info.connection`);\n    }\n\n    private isMessageID(id: string, botSendMessageID: string, requestMessageID: string): boolean {\n        return id == botSendMessageID || id == requestMessageID;\n    }\n\n    private isAddToShoppingList(id: string, userToSend: string): boolean {\n        return !!(id.includes('alexa-shoppinglist') && !id.includes('add_position') && userToSend);\n    }\n\n    private isMenuToSend(\n        state: ioBroker.State | null | undefined,\n        id: string,\n        telegramID: string,\n        userToSend: string | null,\n    ): boolean {\n        return !!(typeof state?.val === 'string' && state.val != '' && id == telegramID && state?.ack && userToSend);\n    }\n\n    private async checkInfoConnection(id: string, infoConnectionOfTelegram: string): Promise<boolean> {\n        if (id === infoConnectionOfTelegram) {\n            if (!(await checkIsTelegramActive(infoConnectionOfTelegram))) {\n                this.log.debug('Telegram is not active');\n                return false;\n            }\n            return true;\n        }\n        return true;\n    }\n\n    private async getChatIDAndUserToSend(\n        telegramParams: TelegramParams,\n    ): Promise<{ chatID: string; userToSend: string; error: boolean; errorMessage?: string }> {\n        const { telegramInstance, userListWithChatID } = telegramParams;\n        const chatIDState = await this.getForeignStateAsync(`${telegramInstance}.communicate.requestChatId`);\n\n        if (!chatIDState?.val) {\n            adapter.log.debug('ChatID not found');\n            return { chatID: '', userToSend: '', error: true, errorMessage: 'ChatId not found' };\n        }\n\n        const userToSend = getUserToSendFromUserListWithChatID(userListWithChatID, chatIDState.val.toString());\n        if (!userToSend) {\n            this.log.debug('User to send not found');\n            return { chatID: chatIDState.val.toString(), userToSend: '', error: true, errorMessage: 'User not found' };\n        }\n        return { chatID: chatIDState.val.toString(), userToSend, error: false };\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     *\n     * @param callback - Is called when adapter has closed all connections and released all resources\n     */\n    private onUnload(callback: () => void): void {\n        const timeouts = getTimeouts();\n        try {\n            // Here you must clear all timeouts or intervals that may still be active\n            timeouts.forEach(({ timeout }) => {\n                adapter.clearTimeout(timeout);\n            });\n\n            callback();\n        } catch (e: any) {\n            errorLogger(e, 'Error onUnload', adapter);\n            callback();\n        }\n    }\n\n    onMessage(obj: ioBroker.Message): void {\n        if (typeof obj === 'object' && obj.message) {\n            if (obj.command === 'send') {\n                // e.g. send email or pushover or whatever\n                this.log.info('send command');\n                // Send response in callback if required\n                if (obj.callback) {\n                    this.sendTo(obj.from, obj.command, 'Message received', obj.callback);\n                }\n            }\n        }\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    /**\n     * @param [options] - Adapter options\n     */\n    module.exports = (options: Partial<utils.AdapterOptions<undefined, undefined>> | undefined): TelegramMenu =>\n        new TelegramMenu(options);\n} else {\n    // otherwise start the instance directly\n    (() => new TelegramMenu())();\n}\n"],
  "mappings": "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",
  "names": ["_a", "_b", "userToSend", "error"]
}

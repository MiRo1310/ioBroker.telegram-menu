{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["'use strict';\n/*\n * Created with @iobroker/create-adapter v2.3.0\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from '@iobroker/adapter-core';\n\nimport {\n    checkEvent,\n    editArrayButtons,\n    exchangePlaceholderWithValue,\n    generateActions,\n    generateNewObjectStructure,\n    getMenusWithUserToSend,\n    getUserToSendFromUserListWithChatID,\n} from './lib/action.js';\nimport { _subscribeForeignStatesAsync } from './lib/subscribeStates.js';\nimport { sendToTelegram } from './lib/telegram.js';\nimport { changeValue, decomposeText } from './lib/utilities.js';\nimport { createState } from './lib/createState.js';\nimport { saveMessageIds } from './lib/messageIds.js';\nimport { adapterStartMenuSend } from './lib/adapterStartMenuSend.js';\nimport { checkEveryMenuForData, getStateIdsToListenTo, getTimeouts } from './lib/processData.js';\nimport { deleteMessageAndSendNewShoppingList, shoppingListSubscribeStateAndDeleteItem } from './lib/shoppingList.js';\nimport { debug, error } from './lib/logging.js';\n\nimport type {\n    Checkboxes,\n    DataObject,\n    GeneratedActions,\n    IsUserActiveCheckbox,\n    ListOfMenus,\n    MenuData,\n    MenusWithUsers,\n    NewObjectNavStructureKey,\n    SetStateIds,\n    StartSides,\n    UserListWithChatId,\n} from './lib/telegram-menu.js';\nimport type { BooleanString } from '@/types/app.js';\nimport { checkIsTelegramActive } from './lib/connection.js';\nimport { isDefined, isFalsy, isString } from './lib/global';\n\nconst timeoutKey = '0';\nlet subscribeForeignStateIds: string[];\n\nexport default class TelegramMenu extends utils.Adapter {\n    private static instance: TelegramMenu;\n\n    /**\n     * @param [options] - Adapter options\n     */\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'telegram-menu',\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n        TelegramMenu.instance = this;\n    }\n\n    public static getInstance(): TelegramMenu {\n        return TelegramMenu.instance;\n    }\n\n    private async onReady(): Promise<void> {\n        await this.setState('info.connection', false, true);\n        await createState(this);\n\n        let instanceTelegram: string = this.config.instance;\n        if (!instanceTelegram || instanceTelegram.length == 0) {\n            instanceTelegram = 'telegram.0';\n        }\n        const telegramID = `${instanceTelegram}.communicate.request`;\n        const botSendMessageID = `${instanceTelegram}.communicate.botSendMessageId`;\n        const requestMessageID = `${instanceTelegram}.communicate.requestMessageId`;\n        const infoConnectionOfTelegram = `${instanceTelegram}.info.connection`;\n\n        const checkboxes: Checkboxes = this.config.checkbox as Checkboxes;\n        const one_time_keyboard: boolean = checkboxes.oneTiKey;\n        const resize_keyboard: boolean = checkboxes.resKey;\n        const checkboxNoEntryFound: boolean = checkboxes.checkboxNoValueFound;\n        const sendMenuAfterRestart: boolean = checkboxes.sendMenuAfterRestart;\n        let listOfMenus: ListOfMenus = [];\n        if (this.config.usersInGroup) {\n            listOfMenus = Object.keys(this.config.usersInGroup);\n        }\n        const token = this.config.tokenGrafana;\n        const directoryPicture: string = this.config.directory;\n        const isUserActiveCheckbox: IsUserActiveCheckbox = this.config.userActiveCheckbox;\n        const menusWithUsers: MenusWithUsers = this.config.usersInGroup;\n        const textNoEntryFound: string = this.config.textNoEntry;\n        const userListWithChatID: UserListWithChatId[] = this.config.userListWithChatID;\n        const dataObject: DataObject = this.config.data as DataObject;\n        const startSides: StartSides = {};\n\n        const menuData: MenuData = {\n            data: {},\n        } as MenuData;\n\n        Object.keys(menusWithUsers).forEach(element => {\n            startSides[element] = dataObject.nav[element][0].call;\n        });\n\n        await this.getForeignObject(infoConnectionOfTelegram, async (err, obj) => {\n            try {\n                if (err || obj == null) {\n                    this.log.error(`The State ${infoConnectionOfTelegram} was not found! ${err}`);\n                    return;\n                }\n\n                const isTelegramActive = await checkIsTelegramActive(infoConnectionOfTelegram);\n                if (!isTelegramActive) {\n                    return;\n                }\n\n                const { nav, action } = dataObject;\n\n                this.log.info('Telegram was found');\n\n                for (const name in nav) {\n                    const value = editArrayButtons(nav[name], this);\n\n                    const newObjectStructure = generateNewObjectStructure(value);\n                    if (newObjectStructure) {\n                        menuData.data[name] = newObjectStructure;\n                    }\n\n                    const generatedActions: GeneratedActions | undefined = generateActions(\n                        action[name],\n                        menuData.data[name],\n                    );\n                    if (generatedActions) {\n                        menuData.data[name] = generatedActions?.obj;\n                        subscribeForeignStateIds = generatedActions?.ids;\n                    } else {\n                        debug([{ text: 'No Actions generated!' }]);\n                    }\n\n                    if (subscribeForeignStateIds && subscribeForeignStateIds?.length > 0) {\n                        await _subscribeForeignStatesAsync(subscribeForeignStateIds);\n                    } else {\n                        debug([{ text: 'Nothing to Subscribe!' }]);\n                    }\n\n                    // Subscribe Events\n                    if (dataObject.action[name] && dataObject.action[name].events) {\n                        for (const event of dataObject.action[name].events) {\n                            await _subscribeForeignStatesAsync([event.ID]);\n                        }\n                    }\n                    debug([\n                        { text: 'Menu: ', val: name },\n                        { text: 'Array Buttons: ', val: value },\n                        { text: 'Gen. Actions: ', val: menuData.data[name] },\n                    ]);\n                }\n                debug([\n                    { text: 'Checkbox', val: checkboxes },\n                    { text: 'MenuList', val: listOfMenus },\n                ]);\n\n                if (sendMenuAfterRestart) {\n                    await adapterStartMenuSend(\n                        listOfMenus,\n                        startSides,\n                        isUserActiveCheckbox,\n                        menusWithUsers,\n                        menuData,\n                        userListWithChatID,\n                        instanceTelegram,\n                        resize_keyboard,\n                        one_time_keyboard,\n                    );\n                }\n\n                this.on('stateChange', async (id, state) => {\n                    const setStateIdsToListenTo: SetStateIds[] = getStateIdsToListenTo();\n\n                    const isActive = await this.checkInfoConnection(id, infoConnectionOfTelegram);\n                    if (!isActive) {\n                        return;\n                    }\n\n                    const obj = await this.getChatIDAndUserToSend(instanceTelegram, userListWithChatID);\n                    if (!obj) {\n                        return;\n                    }\n\n                    const { userToSend } = obj;\n\n                    if (isString(state?.val) && state.val.includes('sList:')) {\n                        await shoppingListSubscribeStateAndDeleteItem(\n                            state.val,\n                            instanceTelegram,\n                            userListWithChatID,\n                            resize_keyboard,\n                            one_time_keyboard,\n                        );\n\n                        return;\n                    }\n\n                    if (this.isAddToShoppingList(id, userToSend)) {\n                        await deleteMessageAndSendNewShoppingList(instanceTelegram, userListWithChatID, userToSend);\n                        return;\n                    }\n\n                    if (\n                        state &&\n                        (await checkEvent(\n                            dataObject,\n                            id,\n                            state,\n                            menuData,\n                            userListWithChatID,\n                            instanceTelegram,\n                            resize_keyboard,\n                            one_time_keyboard,\n                            menusWithUsers,\n                        ))\n                    ) {\n                        return;\n                    }\n\n                    if (this.isMessageID(id, botSendMessageID, requestMessageID) && state) {\n                        await saveMessageIds(state, instanceTelegram);\n                    } else if (this.isMenuToSend(state, id, telegramID, userToSend)) {\n                        let value = state?.val;\n                        if (!value || !userToSend) {\n                            return;\n                        }\n\n                        value = value.toString();\n                        const calledValue = value.slice(value.indexOf(']') + 1, value.length);\n                        const menus: NewObjectNavStructureKey[] = getMenusWithUserToSend(menusWithUsers, userToSend);\n\n                        const dataFound = await checkEveryMenuForData({\n                            menuData,\n                            calledValue,\n                            userToSend,\n                            instanceTelegram,\n                            resize_keyboard,\n                            one_time_keyboard,\n                            userListWithChatID,\n                            menus,\n                            isUserActiveCheckbox,\n                            token,\n                            directoryPicture,\n                            timeoutKey,\n                        });\n\n                        debug([\n                            { text: 'Groups with searched User:', val: menus },\n                            { text: 'Data found:', val: dataFound },\n                        ]);\n\n                        if (!dataFound && checkboxNoEntryFound && userToSend) {\n                            debug([{ text: 'No Entry found' }]);\n                            await sendToTelegram(\n                                userToSend,\n                                textNoEntryFound,\n                                undefined,\n                                instanceTelegram,\n                                resize_keyboard,\n                                one_time_keyboard,\n                                userListWithChatID,\n                                'false',\n                            );\n                        }\n                        return;\n                    }\n                    if (\n                        state &&\n                        setStateIdsToListenTo &&\n                        setStateIdsToListenTo.find((element: { id: string }) => element.id == id)\n                    ) {\n                        debug([\n                            { text: 'State, which is listen to was changed:', val: id },\n                            { text: 'State:', val: state },\n                        ]);\n\n                        setStateIdsToListenTo.forEach((element, key: number) => {\n                            if (element.id == id) {\n                                debug([\n                                    { text: 'Send Value:', val: element },\n                                    { text: 'Ack:', val: state.ack },\n                                ]);\n\n                                if (\n                                    !isFalsy(element.confirm) &&\n                                    !state?.ack &&\n                                    element.returnText.includes('{confirmSet:')\n                                ) {\n                                    const substring = decomposeText(\n                                        element.returnText,\n                                        '{confirmSet:',\n                                        '}',\n                                    ).substring.split(':');\n                                    debug([{ text: 'Substring:', val: substring }]);\n                                    let text = '';\n                                    if (isDefined(state.val)) {\n                                        text =\n                                            substring[2] && substring[2].includes('noValue')\n                                                ? substring[1]\n                                                : exchangePlaceholderWithValue(substring[1], state.val.toString());\n                                    }\n                                    debug([{ text: 'Return-text:', val: text }]);\n\n                                    if (text === '') {\n                                        error([{ text: 'The return text cannot be empty, please check.' }]);\n                                    }\n\n                                    sendToTelegram(\n                                        element.userToSend,\n                                        text,\n                                        undefined,\n                                        instanceTelegram,\n                                        resize_keyboard,\n                                        one_time_keyboard,\n                                        userListWithChatID,\n                                        element.parse_mode as BooleanString,\n                                    ).catch((e: { message: any; stack: any }) => {\n                                        error([\n                                            { text: 'Error SendToTelegram' },\n                                            { val: e.message },\n                                            { text: 'Error', val: e.stack },\n                                        ]);\n                                    });\n                                    return;\n                                }\n                                debug([\n                                    {\n                                        text: 'Data: ',\n                                        val: { confirm: element.confirm, ack: state?.ack, val: state?.val },\n                                    },\n                                ]);\n                                if (!isFalsy(element.confirm) && state?.ack) {\n                                    let textToSend = element.returnText;\n\n                                    if (textToSend.includes('{confirmSet:')) {\n                                        const substring = decomposeText(textToSend, '{confirmSet:', '}').substring;\n                                        textToSend = textToSend.replace(substring, '');\n                                    }\n\n                                    let value: string | number = '';\n                                    let valueChange: string | number | null = null;\n                                    const resultChange = changeValue(textToSend, state.val?.toString() || '');\n                                    if (resultChange) {\n                                        valueChange = resultChange.val;\n                                        textToSend = resultChange.textToSend;\n                                    }\n\n                                    if (textToSend?.toString().includes('{novalue}')) {\n                                        value = '';\n                                        textToSend = textToSend.replace('{novalue}', '');\n                                    } else if (isDefined(state?.val)) {\n                                        value = state.val?.toString() || '';\n                                    }\n                                    if (valueChange) {\n                                        value = valueChange;\n                                    }\n\n                                    debug([{ text: 'Value to send:', val: value }]);\n                                    textToSend = exchangePlaceholderWithValue(textToSend, value);\n\n                                    sendToTelegram(\n                                        element.userToSend,\n                                        textToSend,\n                                        undefined,\n                                        instanceTelegram,\n                                        resize_keyboard,\n                                        one_time_keyboard,\n                                        userListWithChatID,\n                                        element.parse_mode as BooleanString,\n                                    ).catch((e: { message: any; stack: any }) => {\n                                        error([\n                                            { text: 'Error sendToTelegram' },\n                                            { val: e.message },\n                                            { text: 'Error', val: e.stack },\n                                        ]);\n                                    });\n\n                                    setStateIdsToListenTo.splice(key, 1);\n                                }\n                            }\n                        });\n                    }\n                });\n            } catch (e: any) {\n                error([{ text: 'Error onReady' }, { val: e.message }, { text: 'Error', val: e.stack }]);\n            }\n        });\n\n        await this.subscribeForeignStatesAsync(botSendMessageID);\n        await this.subscribeForeignStatesAsync(requestMessageID);\n        await this.subscribeForeignStatesAsync(`${instanceTelegram}.communicate.requestChatId`);\n        await this.subscribeForeignStatesAsync(telegramID);\n        await this.subscribeForeignStatesAsync(`${instanceTelegram}.info.connection`);\n    }\n\n    private isMessageID(id: string, botSendMessageID: string, requestMessageID: string): boolean {\n        return id == botSendMessageID || id == requestMessageID;\n    }\n\n    private isAddToShoppingList(id: string, userToSend: string): boolean {\n        return !!(id.includes('alexa-shoppinglist') && !id.includes('add_position') && userToSend);\n    }\n\n    private isMenuToSend(\n        state: ioBroker.State | null | undefined,\n        id: string,\n        telegramID: string,\n        userToSend: string | null,\n    ): boolean {\n        return !!(\n            state &&\n            typeof state.val === 'string' &&\n            state.val != '' &&\n            id == telegramID &&\n            state?.ack &&\n            userToSend\n        );\n    }\n\n    private async checkInfoConnection(id: string, infoConnectionOfTelegram: string): Promise<boolean> {\n        if (id === infoConnectionOfTelegram) {\n            const isActive = await checkIsTelegramActive(infoConnectionOfTelegram);\n            if (!isActive) {\n                this.log.debug('Telegram is not active');\n                return false;\n            }\n            return true;\n        }\n        return true;\n    }\n\n    private async getChatIDAndUserToSend(\n        instanceTelegram: string,\n        userListWithChatID: UserListWithChatId[],\n    ): Promise<{ chatID: string; userToSend: string } | undefined> {\n        const chatID = await this.getForeignStateAsync(`${instanceTelegram}.communicate.requestChatId`);\n\n        if (!chatID?.val) {\n            debug([{ text: 'ChatID not found' }]);\n            return;\n        }\n\n        const userToSend = getUserToSendFromUserListWithChatID(userListWithChatID, chatID.val.toString());\n        if (!userToSend) {\n            this.log.debug('User to send not found');\n            return;\n        }\n        return { chatID: chatID.val.toString(), userToSend };\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     *\n     * @param callback - Is called when adapter has closed all connections and released all resources\n     */\n    private onUnload(callback: () => void): void {\n        const timeouts = getTimeouts();\n        try {\n            // Here you must clear all timeouts or intervals that may still be active\n            timeouts.forEach((element: { timeout: string | number | NodeJS.Timeout | undefined }) => {\n                clearTimeout(element.timeout);\n            });\n\n            callback();\n        } catch (e: any) {\n            this.log.error(`Error onUnload  ${e}`);\n            callback();\n        }\n    }\n\n    onMessage(obj: ioBroker.Message): void {\n        if (typeof obj === 'object' && obj.message) {\n            if (obj.command === 'send') {\n                // e.g. send email or pushover or whatever\n                this.log.info('send command');\n\n                // Send response in callback if required\n                if (obj.callback) {\n                    this.sendTo(obj.from, obj.command, 'Message received', obj.callback);\n                }\n            }\n        }\n    }\n}\nlet adapter;\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    /**\n     * @param [options] - Adapter options\n     */\n    adapter = (options: Partial<utils.AdapterOptions<undefined, undefined>> | undefined): TelegramMenu =>\n        new TelegramMenu(options);\n} else {\n    // otherwise start the instance directly\n    new TelegramMenu();\n}\nexport { adapter };\n"],
  "mappings": "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",
  "names": ["obj"]
}

{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["'use strict';\n/*\n * Created with @iobroker/create-adapter v2.3.0\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from '@iobroker/adapter-core';\n\nimport { checkEvent, generateActions, getUserToSendFromUserListWithChatID } from './app/action.js';\nimport { _subscribeForeignStatesAsync } from './app/subscribeStates.js';\nimport { sendToTelegram } from './app/telegram.js';\nimport { createState } from './app/createState.js';\nimport { saveMessageIds } from './app/messageIds.js';\nimport { adapterStartMenuSend } from './app/adapterStartMenuSend.js';\nimport { checkEveryMenuForData, getStateIdsToListenTo, getTimeouts } from './app/processData.js';\nimport { deleteMessageAndSendNewShoppingList, shoppingListSubscribeStateAndDeleteItem } from './app/shoppingList.js';\nimport { errorLogger } from './app/logging.js';\nimport type {\n    ListOfMenus,\n    MenuData,\n    PrimitiveType,\n    SetStateIds,\n    TelegramParams,\n    UserListWithChatId,\n} from './types/types';\nimport { checkIsTelegramActive } from './app/connection.js';\nimport { decomposeText, getValueToExchange, isString, jsonString } from './lib/string';\nimport { isDefined, isFalsy } from './lib/utils';\nimport {\n    exchangePlaceholderWithValue,\n    getListOfMenusIncludingUser,\n    getNewStructure,\n    getStartSides,\n    splitNavigation,\n} from './lib/appUtils';\n\nconst timeoutKey = '0';\nlet subscribeForeignStateIds: string[];\nexport let adapter: TelegramMenu;\n\nexport default class TelegramMenu extends utils.Adapter {\n    private static instance: TelegramMenu;\n\n    /**\n     * @param [options] - Adapter options\n     */\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'telegram-menu',\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n        TelegramMenu.instance = this;\n    }\n\n    private async onReady(): Promise<void> {\n        adapter = this;\n        await this.setState('info.connection', false, true);\n        await createState(this);\n\n        let instanceTelegram = this.config.instance;\n        if (!instanceTelegram || instanceTelegram.length == 0) {\n            instanceTelegram = 'telegram.0';\n        }\n\n        const telegramID = `${instanceTelegram}.communicate.request`;\n        const botSendMessageID = `${instanceTelegram}.communicate.botSendMessageId`;\n        const requestMessageID = `${instanceTelegram}.communicate.requestMessageId`;\n        const infoConnectionOfTelegram = `${instanceTelegram}.info.connection`;\n\n        const checkboxes = this.config.checkbox;\n        const one_time_keyboard = checkboxes.oneTiKey;\n        const resize_keyboard = checkboxes.resKey;\n        const checkboxNoEntryFound = checkboxes.checkboxNoValueFound;\n        const sendMenuAfterRestart = checkboxes.sendMenuAfterRestart;\n        let listOfMenus: ListOfMenus = [];\n        if (this.config.usersInGroup) {\n            listOfMenus = Object.keys(this.config.usersInGroup);\n        }\n        const token = this.config.tokenGrafana;\n        const directoryPicture = this.config.directory;\n        const isUserActiveCheckbox = this.config.userActiveCheckbox;\n        const menusWithUsers = this.config.usersInGroup;\n        const textNoEntryFound: string = this.config.textNoEntry;\n        const userListWithChatID = this.config.userListWithChatID;\n        const dataObject = this.config.data;\n\n        const menuData: MenuData = {};\n        const startSides = getStartSides(menusWithUsers, dataObject);\n        try {\n            await this.getForeignObject(infoConnectionOfTelegram, async (err, obj) => {\n                if (err || obj == null) {\n                    this.log.error(`The State ${infoConnectionOfTelegram} was not found! ${err}`);\n                    return;\n                }\n\n                if (!(await checkIsTelegramActive(infoConnectionOfTelegram))) {\n                    return;\n                }\n\n                const { nav, action } = dataObject;\n\n                this.log.info('Telegram was found');\n\n                for (const name in nav) {\n                    const splittedNavigation = splitNavigation(nav[name]);\n                    const newStructure = getNewStructure(splittedNavigation);\n                    const generatedActions = generateActions(action[name], newStructure);\n\n                    menuData[name] = newStructure;\n                    if (generatedActions) {\n                        menuData[name] = generatedActions?.obj;\n                        subscribeForeignStateIds = generatedActions?.ids;\n                    } else {\n                        adapter.log.debug('No Actions generated!');\n                    }\n\n                    if (subscribeForeignStateIds && subscribeForeignStateIds?.length > 0) {\n                        await _subscribeForeignStatesAsync(subscribeForeignStateIds);\n                    } else {\n                        adapter.log.debug('Nothing to Subscribe!');\n                    }\n\n                    // Subscribe Events\n                    if (dataObject.action[name] && dataObject.action[name].events) {\n                        for (const event of dataObject.action[name].events) {\n                            await _subscribeForeignStatesAsync([event.ID]);\n                        }\n                    }\n                    adapter.log.debug(`Menu: ${name}`);\n                    adapter.log.debug(`Array Buttons: ${jsonString(splittedNavigation)}`);\n                    adapter.log.debug(`Gen. Actions: ${jsonString(menuData[name])}`);\n                }\n                console.log(JSON.stringify(menuData));\n                adapter.log.debug(`Checkbox: ${jsonString(checkboxes)}`);\n                adapter.log.debug(`MenuList: ${jsonString(listOfMenus)}`);\n\n                if (sendMenuAfterRestart) {\n                    await adapterStartMenuSend(\n                        listOfMenus,\n                        startSides,\n                        isUserActiveCheckbox,\n                        menusWithUsers,\n                        menuData,\n                        userListWithChatID,\n                        instanceTelegram,\n                        resize_keyboard,\n                        one_time_keyboard,\n                    );\n                }\n\n                this.on('stateChange', async (id, state) => {\n                    const setStateIdsToListenTo: SetStateIds[] = getStateIdsToListenTo();\n\n                    const isActive = await this.checkInfoConnection(id, infoConnectionOfTelegram);\n                    if (!isActive) {\n                        return;\n                    }\n\n                    const obj = await this.getChatIDAndUserToSend(instanceTelegram, userListWithChatID);\n                    if (!obj) {\n                        return;\n                    }\n\n                    const { userToSend } = obj;\n\n                    if (isString(state?.val) && state.val.includes('sList:')) {\n                        await shoppingListSubscribeStateAndDeleteItem(\n                            state.val,\n                            instanceTelegram,\n                            userListWithChatID,\n                            resize_keyboard,\n                            one_time_keyboard,\n                        );\n\n                        return;\n                    }\n\n                    if (this.isAddToShoppingList(id, userToSend)) {\n                        await deleteMessageAndSendNewShoppingList(instanceTelegram, userListWithChatID, userToSend);\n                        return;\n                    }\n\n                    if (\n                        state &&\n                        (await checkEvent(\n                            dataObject,\n                            id,\n                            state,\n                            menuData,\n                            userListWithChatID,\n                            instanceTelegram,\n                            resize_keyboard,\n                            one_time_keyboard,\n                            menusWithUsers,\n                        ))\n                    ) {\n                        return;\n                    }\n\n                    if (this.isMessageID(id, botSendMessageID, requestMessageID) && state) {\n                        await saveMessageIds(state, instanceTelegram);\n                    } else if (this.isMenuToSend(state, id, telegramID, userToSend)) {\n                        let value = state?.val;\n                        if (!value || !userToSend) {\n                            return;\n                        }\n\n                        value = value.toString();\n                        const calledValue = value.slice(value.indexOf(']') + 1, value.length);\n                        const menus = getListOfMenusIncludingUser(menusWithUsers, userToSend);\n\n                        const dataFound = await checkEveryMenuForData({\n                            menuData,\n                            calledValue,\n                            userToSend,\n                            telegramInstance: instanceTelegram,\n                            resize_keyboard,\n                            one_time_keyboard,\n                            userListWithChatID,\n                            menus,\n                            isUserActiveCheckbox,\n                            token,\n                            directoryPicture,\n                            timeoutKey,\n                        });\n\n                        this.log.debug(`Groups with searched User: ${jsonString(menus)}`);\n                        this.log.debug(`Data found: ${dataFound}`);\n\n                        if (!dataFound && checkboxNoEntryFound && userToSend) {\n                            adapter.log.debug('No Entry found');\n                            await sendToTelegram({\n                                userToSend,\n                                textToSend: textNoEntryFound,\n                                telegramInstance: instanceTelegram,\n                                resize_keyboard,\n                                one_time_keyboard,\n                                userListWithChatID,\n                            });\n                        }\n                        return;\n                    }\n                    if (\n                        state &&\n                        setStateIdsToListenTo &&\n                        setStateIdsToListenTo.find((element: { id: string }) => element.id == id)\n                    ) {\n                        adapter.log.debug(`State, which is listen to was changed: ${id}`);\n                        adapter.log.debug(`State: ${jsonString(state)}`);\n\n                        setStateIdsToListenTo.forEach((element, key: number) => {\n                            const telegramParams: TelegramParams = {\n                                telegramInstance: instanceTelegram,\n                                one_time_keyboard,\n                                resize_keyboard,\n                                userToSend: element.userToSend,\n                            };\n                            if (element.id == id) {\n                                adapter.log.debug(`Send Value: ${jsonString(element)}`);\n                                adapter.log.debug(`State: ${jsonString(state)}`);\n\n                                if (\n                                    !isFalsy(element.confirm) &&\n                                    !state?.ack &&\n                                    element.returnText.includes('{confirmSet:')\n                                ) {\n                                    const substring = decomposeText(\n                                        element.returnText,\n                                        '{confirmSet:',\n                                        '}',\n                                    ).substring.split(':');\n                                    adapter.log.debug(`Substring: ${jsonString(substring)}`);\n                                    let text = '';\n                                    if (isDefined(state.val)) {\n                                        text = substring[2]?.includes('noValue')\n                                            ? substring[1]\n                                            : exchangePlaceholderWithValue(substring[1], state.val.toString());\n                                    }\n                                    adapter.log.debug(`Return-text: ${text}`);\n\n                                    if (text === '') {\n                                        adapter.log.error('The return text cannot be empty, please check.');\n                                    }\n\n                                    sendToTelegram({\n                                        textToSend: text,\n                                        userListWithChatID,\n                                        parse_mode: element.parse_mode,\n                                        ...telegramParams,\n                                    }).catch((e: { message: any; stack: any }) => {\n                                        errorLogger('Error SendToTelegram', e, adapter);\n                                    });\n                                    return;\n                                }\n                                adapter.log.debug(\n                                    `Data: ${jsonString({ confirm: element.confirm, ack: state?.ack, val: state?.val })}`,\n                                );\n\n                                if (!isFalsy(element.confirm) && state?.ack) {\n                                    let textToSend = element.returnText;\n\n                                    if (textToSend.includes('{confirmSet:')) {\n                                        const substring = decomposeText(textToSend, '{confirmSet:', '}').substring;\n                                        textToSend = textToSend.replace(substring, '');\n                                    }\n\n                                    let value: PrimitiveType = '';\n                                    let valueChange: PrimitiveType | null = null;\n                                    const {\n                                        newValue,\n                                        textToSend: changedText,\n                                        error,\n                                    } = getValueToExchange(adapter, textToSend, state.val?.toString() || '');\n                                    if (!error) {\n                                        valueChange = newValue;\n                                        textToSend = changedText;\n                                    }\n\n                                    if (textToSend?.toString().includes('{novalue}')) {\n                                        value = '';\n                                        textToSend = textToSend.replace('{novalue}', '');\n                                    } else if (isDefined(state?.val)) {\n                                        value = state.val?.toString() || '';\n                                    }\n                                    if (isDefined(valueChange)) {\n                                        value = valueChange;\n                                    }\n\n                                    adapter.log.debug(`Value to send: ${value}`);\n                                    textToSend = exchangePlaceholderWithValue(textToSend, value);\n\n                                    sendToTelegram({\n                                        userToSend: element.userToSend,\n                                        textToSend: textToSend,\n                                        telegramInstance: instanceTelegram,\n                                        resize_keyboard: resize_keyboard,\n                                        one_time_keyboard: one_time_keyboard,\n                                        userListWithChatID: userListWithChatID,\n                                        parse_mode: element.parse_mode,\n                                    }).catch((e: { message: any; stack: any }) => {\n                                        errorLogger('Error sendToTelegram', e, adapter);\n                                    });\n\n                                    setStateIdsToListenTo.splice(key, 1);\n                                }\n                            }\n                        });\n                    }\n                });\n            });\n        } catch (e: any) {\n            errorLogger('Error onReady', e, adapter);\n        }\n\n        await this.subscribeForeignStatesAsync(botSendMessageID);\n        await this.subscribeForeignStatesAsync(requestMessageID);\n        await this.subscribeForeignStatesAsync(`${instanceTelegram}.communicate.requestChatId`);\n        await this.subscribeForeignStatesAsync(telegramID);\n        await this.subscribeForeignStatesAsync(`${instanceTelegram}.info.connection`);\n    }\n\n    private isMessageID(id: string, botSendMessageID: string, requestMessageID: string): boolean {\n        return id == botSendMessageID || id == requestMessageID;\n    }\n\n    private isAddToShoppingList(id: string, userToSend: string): boolean {\n        return !!(id.includes('alexa-shoppinglist') && !id.includes('add_position') && userToSend);\n    }\n\n    private isMenuToSend(\n        state: ioBroker.State | null | undefined,\n        id: string,\n        telegramID: string,\n        userToSend: string | null,\n    ): boolean {\n        return !!(\n            state &&\n            typeof state.val === 'string' &&\n            state.val != '' &&\n            id == telegramID &&\n            state?.ack &&\n            userToSend\n        );\n    }\n\n    private async checkInfoConnection(id: string, infoConnectionOfTelegram: string): Promise<boolean> {\n        if (id === infoConnectionOfTelegram) {\n            const isActive = await checkIsTelegramActive(infoConnectionOfTelegram);\n            if (!isActive) {\n                this.log.debug('Telegram is not active');\n                return false;\n            }\n            return true;\n        }\n        return true;\n    }\n\n    private async getChatIDAndUserToSend(\n        instanceTelegram: string,\n        userListWithChatID: UserListWithChatId[],\n    ): Promise<{ chatID: string; userToSend: string } | undefined> {\n        const chatID = await this.getForeignStateAsync(`${instanceTelegram}.communicate.requestChatId`);\n\n        if (!chatID?.val) {\n            adapter.log.debug('ChatID not found');\n            return;\n        }\n\n        const userToSend = getUserToSendFromUserListWithChatID(userListWithChatID, chatID.val.toString());\n        if (!userToSend) {\n            this.log.debug('User to send not found');\n            return;\n        }\n        return { chatID: chatID.val.toString(), userToSend };\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     *\n     * @param callback - Is called when adapter has closed all connections and released all resources\n     */\n    private onUnload(callback: () => void): void {\n        const timeouts = getTimeouts();\n        try {\n            // Here you must clear all timeouts or intervals that may still be active\n            timeouts.forEach(element => {\n                adapter.clearTimeout(element.timeout);\n            });\n\n            callback();\n        } catch (e: any) {\n            errorLogger(e, 'Error onUnload', adapter);\n            callback();\n        }\n    }\n\n    onMessage(obj: ioBroker.Message): void {\n        if (typeof obj === 'object' && obj.message) {\n            if (obj.command === 'send') {\n                // e.g. send email or pushover or whatever\n                this.log.info('send command');\n\n                // Send response in callback if required\n                if (obj.callback) {\n                    this.sendTo(obj.from, obj.command, 'Message received', obj.callback);\n                }\n            }\n        }\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    /**\n     * @param [options] - Adapter options\n     */\n    module.exports = (options: Partial<utils.AdapterOptions<undefined, undefined>> | undefined): TelegramMenu =>\n        new TelegramMenu(options);\n} else {\n    // otherwise start the instance directly\n    (() => new TelegramMenu())();\n}\n"],
  "mappings": "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",
  "names": ["obj"]
}

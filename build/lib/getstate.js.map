{
  "version": 3,
  "sources": ["../../src/lib/getstate.ts"],
  "sourcesContent": ["import { sendToTelegram, sendToTelegramSubmenu } from './telegram';\nimport { bindingFunc, roundValue, calcValue, idBySelector } from './action';\nimport { createKeyboardFromJson, createTextTableFromJson } from './jsonTable';\nimport { processTimeIdLc, processTimeValue, changeValue } from './utilities';\nimport { decomposeText, isDefined } from './global';\nimport { debug, error } from './logging';\nimport TelegramMenu from '../main';\nimport type { Part, UserListWithChatId } from './telegram-menu';\n\nfunction getState(\n    part: Part,\n    userToSend: string,\n    telegramInstance: string,\n    one_time_keyboard: boolean,\n    resize_keyboard: boolean,\n    userListWithChatID: UserListWithChatId[],\n): void {\n    const _this = TelegramMenu.getInstance();\n    let text = '';\n    let i = 1;\n    // Parse Mode ist nur immer im ersten Element\n    const parse_mode = part.getData?.[0].parse_mode || 'false';\n\n    part.getData?.forEach(async element => {\n        try {\n            debug([{ text: 'Get Value ID:', val: element.id }]);\n            const specifiedSelektor = 'functions=';\n            const id = element.id;\n            let textToSend = '';\n\n            if (id.indexOf(specifiedSelektor) != -1) {\n                await idBySelector(\n                    _this,\n                    id,\n                    element.text,\n                    userToSend,\n                    element.newline,\n                    telegramInstance,\n                    one_time_keyboard,\n                    resize_keyboard,\n                    userListWithChatID,\n                );\n                return;\n            }\n\n            if (element.text.includes('binding:')) {\n                debug([{ text: 'Binding' }]);\n                await bindingFunc(\n                    element.text,\n                    userToSend,\n                    telegramInstance,\n                    one_time_keyboard,\n                    resize_keyboard,\n                    userListWithChatID,\n                    parse_mode,\n                );\n                return;\n            }\n\n            await _this.getForeignStateAsync(id).then(async (value: ioBroker.State | null | undefined) => {\n                if (!isDefined(value)) {\n                    error([{ text: 'The state is empty!' }]);\n                    return;\n                }\n                const valueForJson: string = value.val?.toString() ?? '';\n                debug([{ text: 'State:', val: value }]);\n\n                let val: string | number = valueForJson.replace(/\\\\/g, '').replace(/\"/g, '');\n\n                let newline = '';\n                if (element.newline === 'true') {\n                    newline = '\\n';\n                }\n                if (element.text) {\n                    textToSend = element.text.toString();\n                    if (element.text.includes('{time.lc') || element.text.includes('{time.ts')) {\n                        textToSend = (await processTimeIdLc(element.text, id)) || '';\n                        val = '';\n                    }\n                    if (textToSend.includes('{time}')) {\n                        textToSend = processTimeValue(textToSend, value);\n                        val = '';\n                    }\n                    if (textToSend.includes('math:')) {\n                        const result = calcValue(_this, textToSend, val);\n                        if (result) {\n                            textToSend = result.textToSend;\n                            val = result.val;\n                            _this.log.debug(JSON.stringify({ textToSend: textToSend, val: val }));\n                        }\n                    }\n                    if (textToSend.includes('round:')) {\n                        const result = roundValue(val, textToSend);\n                        if (result) {\n                            _this.log.debug(\n                                `The Value was rounded ${JSON.stringify(val)} to ${JSON.stringify(result.val)}`,\n                            );\n                            val = result.val;\n                            textToSend = result.textToSend;\n                        }\n                    }\n                    if (textToSend.includes('{json')) {\n                        if (decomposeText(textToSend, '{json', '}').substring.includes('TextTable')) {\n                            const result = createTextTableFromJson(valueForJson, textToSend);\n                            if (result) {\n                                await sendToTelegram(\n                                    userToSend,\n                                    result,\n                                    undefined,\n                                    telegramInstance,\n                                    one_time_keyboard,\n                                    resize_keyboard,\n                                    userListWithChatID,\n                                    parse_mode,\n                                );\n                                return;\n                            }\n                            _this.log.debug('Cannot create a Text-Table');\n                        } else {\n                            const result = createKeyboardFromJson(valueForJson, textToSend, element.id, userToSend);\n                            if (valueForJson && valueForJson.length > 0) {\n                                if (result && result.text && result.keyboard) {\n                                    sendToTelegramSubmenu(\n                                        userToSend,\n                                        result.text,\n                                        result.keyboard,\n                                        telegramInstance,\n                                        userListWithChatID,\n                                        parse_mode,\n                                    );\n                                }\n                                return;\n                            }\n                            await sendToTelegram(\n                                userToSend,\n                                'The state is empty!',\n                                undefined,\n                                telegramInstance,\n                                one_time_keyboard,\n                                resize_keyboard,\n                                userListWithChatID,\n                                parse_mode,\n                            );\n                            _this.log.debug('The state is empty!');\n                            return;\n                        }\n                    }\n\n                    const resultChange = changeValue(textToSend, val);\n\n                    if (resultChange) {\n                        debug([{ text: 'Value Changed to:', val: resultChange }]);\n                        val = resultChange.val;\n                        textToSend = resultChange.textToSend;\n                    } else {\n                        debug([{ text: 'No Change' }]);\n                    }\n                    if (textToSend.indexOf('&&') != -1) {\n                        text += `${textToSend.replace('&&', val.toString())}${newline}`;\n                    } else {\n                        text += `${textToSend} ${val}${newline}`;\n                    }\n                } else {\n                    text += `${val} ${newline}`;\n                }\n                debug([{ text: 'Text:', val: text }]);\n\n                if (i == part.getData?.length) {\n                    if (userToSend) {\n                        await sendToTelegram(\n                            userToSend,\n                            text,\n                            undefined,\n                            telegramInstance,\n                            one_time_keyboard,\n                            resize_keyboard,\n                            userListWithChatID,\n                            parse_mode,\n                        );\n                    }\n                }\n                i++;\n            });\n        } catch (error: any) {\n            error({\n                array: [\n                    { text: 'Error GetData:', val: error.message },\n                    { text: 'Stack:', val: error.stack },\n                ],\n            });\n        }\n    });\n}\n\nexport { getState };\n"],
  "mappings": "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",
  "names": ["TelegramMenu", "_a", "_b", "error"]
}

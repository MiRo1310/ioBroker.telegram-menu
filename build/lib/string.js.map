{
  "version": 3,
  "sources": ["../../src/lib/string.ts"],
  "sourcesContent": ["import { config } from '../config/config';\nimport type {\n    Adapter,\n    BooleanString,\n    DecomposeTextReturnType,\n    ExchangeValueReturn,\n    PrimitiveType,\n    StringReplacerObj,\n} from '../types/types';\nimport { isTruthy } from './utils';\nimport { errorLogger } from '../app/logging';\n\nexport const jsonString = (val?: string | number | boolean | object | null): string => JSON.stringify(val);\n\nexport function parseJSON<T>(\n    val: string,\n    adapter?: Adapter,\n): { json: string; isValidJson: false } | { json: T; isValidJson: true } {\n    try {\n        return { json: JSON.parse(val) as T, isValidJson: true };\n    } catch (e) {\n        if (adapter) {\n            errorLogger('Error parseJSON:', e, adapter);\n        }\n        return { json: val, isValidJson: false };\n    }\n}\n\nexport const replaceAll = (text: string, searchValue: string, replaceValue: string): string => {\n    const escapedSearchValue = searchValue.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // Escape-Sonderzeichen\n    return text.replace(new RegExp(escapedSearchValue, 'g'), replaceValue);\n};\n\nexport const replaceAllItems = (text: string, searched: (string | { search: string; val: string })[]): string => {\n    searched.forEach(item => {\n        if (typeof item === 'string') {\n            text = replaceAll(text, item, '');\n        } else {\n            text = replaceAll(text, item.search, item.val);\n        }\n    });\n    return text;\n};\n\nexport const removeQuotes = (text: string): string => text.replace(/['\"]/g, '');\n\nexport const cleanUpString = (text?: string): string => {\n    if (!text) {\n        return '';\n    }\n    return text\n        .replace(/^['\"]|['\"]$/g, '') // Entferne Anf\u00FChrungszeichen am Anfang/Ende\n        .replace(/\\\\n/g, '\\n') // Ersetze \\n durch einen echten Zeilenumbruch\n        .replace(/ \\\\\\n/g, '\\n') // Ersetze \\n mit Leerzeichen davor durch einen echten Zeilenumbruch\n        .replace(/\\\\(?!n)/g, ''); // Entferne alle Backslashes, die nicht von einem 'n' gefolgt werden\n};\n\nexport function decomposeText(text: string, firstSearch: string, secondSearch: string): DecomposeTextReturnType {\n    const startindex = text.indexOf(firstSearch);\n    const endindex = text.indexOf(secondSearch, startindex);\n    const substring = text.substring(startindex, endindex + secondSearch.length);\n    const substringExcludedSearch = stringReplacer(substring, [firstSearch, secondSearch]);\n    const textWithoutSubstring = text.replace(substring, '').trim();\n    return {\n        startindex,\n        endindex,\n        substring,\n        textExcludeSubstring: textWithoutSubstring,\n        substringExcludeSearch: substringExcludedSearch,\n    };\n}\n// TODO : Move to utils\nexport const getValueToExchange = (adapter: Adapter, textToSend: string, val: PrimitiveType): ExchangeValueReturn => {\n    //TODO Use JSON => change{\"true\":\"W\u00E4rmepumpe ist verbunden\",\"false\":\"W\u00E4rmepumpe ist nicht verbunden\"}\n    if (textToSend.includes(config.change.start)) {\n        const { start, end, command } = config.change;\n        const { startindex, endindex, substring } = decomposeText(textToSend, start, end); // change{\"true\":\"an\",\"false\":\"aus\"}\n\n        const modifiedString = replaceAll(substring, \"'\", '\"').replace(command, ''); // {\"true\":\"an\",\"false\":\"aus\"}\n\n        const { json, isValidJson } = parseJSON<Record<string, string>>(modifiedString);\n\n        if (isValidJson) {\n            return {\n                newValue: json[String(val)] ?? val,\n                textToSend: textToSend.substring(0, startindex) + textToSend.substring(endindex + 1),\n                error: false,\n            };\n        }\n        adapter.log.error(`There is a error in your input: ${modifiedString}`);\n        return { newValue: val, textToSend, error: true };\n    }\n    return { textToSend, newValue: val, error: false };\n};\n\nexport const isString = (value: unknown): value is string => typeof value === 'string';\n\nexport function stringReplacer(substring: string, valueToReplace: string[] | StringReplacerObj[]): string {\n    if (typeof valueToReplace[0] === 'string') {\n        (valueToReplace as string[]).forEach(item => {\n            substring = substring.replace(item, '');\n        });\n        return substring;\n    }\n\n    (valueToReplace as StringReplacerObj[]).forEach(({ val, newValue }) => {\n        substring = substring.replace(val, newValue);\n    });\n    return substring;\n}\n\nexport const pad = (value: number, length: number = 2): string => {\n    if (value < 0) {\n        return `-${(value * -1).toString().padStart(length - 1, '0')}`;\n    }\n    return value.toString().padStart(length, '0');\n};\n\nexport function getNewline(newline: BooleanString): '' | '\\n' {\n    return isTruthy(newline) ? '\\n' : '';\n}\n\nexport function isBooleanString(str: string): boolean {\n    return str === 'true' || str === 'false';\n}\n\nexport const isNonEmptyString = (str: string): boolean => str.trim() !== '';\nexport const isEmptyString = (str: string): boolean => str.trim() === '';\n"],
  "mappings": "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",
  "names": []
}

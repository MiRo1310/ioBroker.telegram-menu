{
  "version": 3,
  "sources": ["../../src/lib/telegram.ts"],
  "sourcesContent": ["import { debug, error } from './logging';\nimport { checkStatusInfo, getChatID, newLine } from './utilities';\nimport TelegramMenu from '../main';\nimport type { BooleanString, Keyboard, Location, ParseModeType, UserListWithChatId } from './telegram-menu';\nimport { isTruthy } from './global';\n\nasync function sendToTelegram({\n    user = '',\n    textToSend,\n    keyboard,\n    instance = 'telegram.0',\n    resize_keyboard = true,\n    one_time_keyboard = true,\n    userListWithChatID,\n    parse_mode,\n}: {\n    user: string;\n    textToSend: string;\n    keyboard?: Keyboard;\n    instance: string;\n    resize_keyboard: boolean;\n    one_time_keyboard: boolean;\n    userListWithChatID: UserListWithChatId[];\n    parse_mode: BooleanString;\n}): Promise<void> {\n    try {\n        const _this = TelegramMenu.getInstance();\n        const chatId = getChatID(userListWithChatID, user);\n        const parse_modeType: ParseModeType = getParseMode(parse_mode);\n        debug([\n            { text: `Send to: ${user} => ${textToSend}` },\n            { text: 'Instance:', val: instance },\n            { text: 'UserListWithChatID\t:', val: userListWithChatID },\n            { text: 'Parse_mode\t:', val: parse_mode },\n            { text: 'ChatId\t:', val: chatId },\n            { text: 'ParseModeType:', val: parse_modeType },\n        ]);\n\n        textToSend = newLine(textToSend);\n        if (!keyboard) {\n            _this.log.debug('No Keyboard');\n            _this.sendTo(\n                instance,\n                'send',\n                {\n                    text: textToSend,\n                    chatId: chatId,\n                    parse_mode: parse_modeType,\n                },\n                function (res: any) {\n                    _this.log.debug(`Sent Value to ${JSON.stringify(res)} users!`);\n                },\n            );\n        } else {\n            const text = await checkStatusInfo(textToSend);\n            _this.sendTo(\n                instance,\n                'send',\n                {\n                    chatId: chatId,\n                    parse_mode: parse_modeType,\n                    text: text,\n                    reply_markup: {\n                        keyboard: keyboard,\n                        resize_keyboard: resize_keyboard,\n                        one_time_keyboard: one_time_keyboard,\n                    },\n                },\n                function (res: any) {\n                    debug([{ text: `Sent Value to ${res} users!` }]);\n                },\n            );\n        }\n    } catch (e: any) {\n        error([\n            { text: 'Error sendToTelegram:', val: e.message },\n            { text: 'Stack:', val: e.stack },\n        ]);\n    }\n}\n\nfunction sendToTelegramSubmenu(\n    user: string,\n    textToSend: string,\n    keyboard: Keyboard,\n    instance = 'telegram.0',\n    userListWithChatID: UserListWithChatId[],\n    parse_mode: BooleanString,\n): void {\n    const _this = TelegramMenu.getInstance();\n    const parseModeType = getParseMode(parse_mode);\n    debug([{ text: 'Send this ParseMode:', val: parseModeType }]);\n    try {\n        const chatId = getChatID(userListWithChatID, user);\n        textToSend = newLine(textToSend);\n        _this.sendTo(instance, 'send', {\n            chatId: chatId,\n            parse_mode: parseModeType,\n            text: textToSend,\n            reply_markup: keyboard,\n        });\n    } catch (e: any) {\n        error([\n            { text: 'Error sendToTelegramSubmenu:', val: e.message },\n            { text: 'Stack:', val: e.stack },\n        ]);\n    }\n}\n\nconst sendLocationToTelegram = async (\n    user: string,\n    data: Location[],\n    instance: string,\n    userListWithChatID: UserListWithChatId[],\n): Promise<void> => {\n    const _this = TelegramMenu.getInstance();\n    try {\n        const chatId = getChatID(userListWithChatID, user);\n        for (const element of data) {\n            if (!(element.latitude || element.longitude)) {\n                continue;\n            }\n\n            const latitude = await _this.getForeignStateAsync(element.latitude);\n            const longitude = await _this.getForeignStateAsync(element.longitude);\n            if (!latitude || !longitude) {\n                continue;\n            }\n            _this.sendTo(instance, {\n                chatId: chatId,\n                latitude: latitude.val,\n                longitude: longitude.val,\n                disable_notification: true,\n            });\n        }\n    } catch (e: any) {\n        error([\n            { text: 'Error sendLocationToTelegram:', val: e.message },\n            { text: 'Stack:', val: e.stack },\n        ]);\n    }\n};\n\nfunction getParseMode(val: BooleanString | boolean): ParseModeType {\n    if (isTruthy(val)) {\n        return 'HTML';\n    }\n    return 'Markdown';\n}\n\nexport { sendToTelegram, sendToTelegramSubmenu, sendLocationToTelegram };\n"],
  "mappings": "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",
  "names": ["TelegramMenu"]
}

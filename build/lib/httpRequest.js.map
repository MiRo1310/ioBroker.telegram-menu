{
  "version": 3,
  "sources": ["../../src/lib/httpRequest.ts"],
  "sourcesContent": ["import axios from 'axios';\nimport { sendToTelegram } from './telegram';\nimport path from 'path';\nimport fs from 'fs';\nimport { debug, error } from './logging';\nimport type { Part, UserListWithChatId } from './telegram-menu';\nimport { checkDirectoryIsOk } from './global';\n\nasync function httpRequest(\n    parts: Part,\n    userToSend: string,\n    instanceTelegram: string,\n    resize_keyboard: boolean,\n    one_time_keyboard: boolean,\n    userListWithChatID: UserListWithChatId[],\n    directoryPicture: string,\n): Promise<boolean | undefined> {\n    if (!parts.httpRequest) {\n        return;\n    }\n    for (const part of parts.httpRequest) {\n        const url = part.url;\n        const userName = part.user;\n        const password = part.password;\n        const method = 'get';\n        debug([{ text: 'URL:', val: url }]);\n        try {\n            //prettier-ignore\n            const response = await axios(\n                userName && password\n                    ? {\n                        method: method,\n                        url: url,\n                        responseType: \"arraybuffer\",\n                        auth: {\n                            username: userName,\n                            password: password,\n                        },\n                    }\n                    : {\n                        method: method,\n                        url: url,\n                        responseType: \"arraybuffer\",\n                    },\n            );\n            if (!part.filename) {\n                return;\n            }\n            if (!checkDirectoryIsOk(directoryPicture)) {\n                return;\n            }\n            const imagePath = path.join(directoryPicture, part.filename);\n\n            fs.writeFileSync(imagePath, Buffer.from(response.data), 'binary');\n            debug([{ text: 'Pic saved:', val: imagePath }]);\n\n            await sendToTelegram(\n                userToSend,\n                imagePath,\n                [],\n                instanceTelegram,\n                resize_keyboard,\n                one_time_keyboard,\n                userListWithChatID,\n                'false',\n            );\n        } catch (e: any) {\n            error([\n                { text: 'Error:', val: e.message },\n                { text: 'Stack:', val: e.stack },\n                { text: 'Server Response:', val: e.response.status },\n                { text: 'Server data:', val: e.response.data },\n            ]);\n        }\n    }\n    return true;\n}\n\nexport { httpRequest };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAkB;AAClB,sBAA+B;AAC/B,kBAAiB;AACjB,gBAAe;AACf,qBAA6B;AAE7B,oBAAmC;AAEnC,eAAe,YACX,OACA,YACA,kBACA,iBACA,mBACA,oBACA,kBAC4B;AAC5B,MAAI,CAAC,MAAM,aAAa;AACpB;AAAA,EACJ;AACA,aAAW,QAAQ,MAAM,aAAa;AAClC,UAAM,MAAM,KAAK;AACjB,UAAM,WAAW,KAAK;AACtB,UAAM,WAAW,KAAK;AACtB,UAAM,SAAS;AACf,8BAAM,CAAC,EAAE,MAAM,QAAQ,KAAK,IAAI,CAAC,CAAC;AAClC,QAAI;AAEA,YAAM,WAAW,UAAM,aAAAA;AAAA,QACnB,YAAY,WACN;AAAA,UACE;AAAA,UACA;AAAA,UACA,cAAc;AAAA,UACd,MAAM;AAAA,YACF,UAAU;AAAA,YACV;AAAA,UACJ;AAAA,QACJ,IACE;AAAA,UACE;AAAA,UACA;AAAA,UACA,cAAc;AAAA,QAClB;AAAA,MACR;AACA,UAAI,CAAC,KAAK,UAAU;AAChB;AAAA,MACJ;AACA,UAAI,KAAC,kCAAmB,gBAAgB,GAAG;AACvC;AAAA,MACJ;AACA,YAAM,YAAY,YAAAC,QAAK,KAAK,kBAAkB,KAAK,QAAQ;AAE3D,gBAAAC,QAAG,cAAc,WAAW,OAAO,KAAK,SAAS,IAAI,GAAG,QAAQ;AAChE,gCAAM,CAAC,EAAE,MAAM,cAAc,KAAK,UAAU,CAAC,CAAC;AAE9C,gBAAM;AAAA,QACF;AAAA,QACA;AAAA,QACA,CAAC;AAAA,QACD;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACJ;AAAA,IACJ,SAAS,GAAQ;AACb,gCAAM;AAAA,QACF,EAAE,MAAM,UAAU,KAAK,EAAE,QAAQ;AAAA,QACjC,EAAE,MAAM,UAAU,KAAK,EAAE,MAAM;AAAA,QAC/B,EAAE,MAAM,oBAAoB,KAAK,EAAE,SAAS,OAAO;AAAA,QACnD,EAAE,MAAM,gBAAgB,KAAK,EAAE,SAAS,KAAK;AAAA,MACjD,CAAC;AAAA,IACL;AAAA,EACJ;AACA,SAAO;AACX;",
  "names": ["axios", "path", "fs"]
}

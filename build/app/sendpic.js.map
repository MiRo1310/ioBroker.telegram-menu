{
  "version": 3,
  "sources": ["../../src/app/sendpic.ts"],
  "sourcesContent": ["import type { Part, TelegramParams, Timeouts } from '@b/types/types';\nimport { isStartside } from '@b/lib/appUtils';\nimport { replaceAll } from '@b/lib/string';\nimport { validateDirectory } from '@b/lib/utils';\nimport { loadWithCurl } from '@b/app/exec';\nimport { sendToTelegram } from '@b/app/telegram';\nimport { errorLogger } from '@b/app/logging';\n\nexport function sendPic(\n    instance: string,\n    part: Part,\n    userToSend: string,\n    telegramParams: TelegramParams,\n    token: string,\n    directoryPicture: string,\n    timeouts: Timeouts[],\n    timeoutKey: string,\n): Timeouts[] {\n    const adapter = telegramParams.adapter;\n    try {\n        part.sendPic?.forEach((element, index) => {\n            const { id, delay, fileName } = element;\n            let path = '';\n            if (!isStartside(id)) {\n                return;\n            }\n            const url = replaceAll(id, '&amp;', '&');\n            path = `${directoryPicture}${fileName}`;\n\n            if (!validateDirectory(adapter, directoryPicture)) {\n                return;\n            }\n\n            if (delay <= 0) {\n                loadWithCurl(\n                    adapter,\n                    token,\n                    path,\n                    url,\n                    async () =>\n                        await sendToTelegram({\n                            instance,\n                            userToSend,\n                            textToSend: path,\n                            telegramParams,\n                        }),\n                );\n                return;\n            }\n            loadWithCurl(adapter, token, path, url);\n            timeoutKey += index;\n\n            const timeout = adapter.setTimeout(\n                async () => {\n                    await sendToTelegram({\n                        instance,\n                        userToSend,\n                        textToSend: path,\n                        telegramParams,\n                    });\n                    let timeoutToClear: Timeouts | undefined = undefined;\n                    timeoutToClear = timeouts.find(item => item.key == timeoutKey);\n\n                    adapter.clearTimeout(timeoutToClear?.timeout);\n                    timeouts = timeouts.filter(item => item.key !== timeoutKey);\n\n                    adapter.log.debug(`Picture has been send with delay ${delay}, path : ${path}`);\n                },\n                parseInt(String(element.delay)),\n            );\n\n            if (timeout) {\n                timeouts.push({ key: timeoutKey, timeout });\n            }\n        });\n        return timeouts;\n    } catch (e: any) {\n        errorLogger('Error send pic:', e, adapter);\n    }\n    return timeouts;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,sBAA4B;AAC5B,oBAA2B;AAC3B,mBAAkC;AAClC,kBAA6B;AAC7B,sBAA+B;AAC/B,qBAA4B;AAErB,SAAS,QACZ,UACA,MACA,YACA,gBACA,OACA,kBACA,UACA,YACU;AAjBd;AAkBI,QAAM,UAAU,eAAe;AAC/B,MAAI;AACA,eAAK,YAAL,mBAAc,QAAQ,CAAC,SAAS,UAAU;AACtC,YAAM,EAAE,IAAI,OAAO,SAAS,IAAI;AAChC,UAAI,OAAO;AACX,UAAI,KAAC,6BAAY,EAAE,GAAG;AAClB;AAAA,MACJ;AACA,YAAM,UAAM,0BAAW,IAAI,SAAS,GAAG;AACvC,aAAO,GAAG,gBAAgB,GAAG,QAAQ;AAErC,UAAI,KAAC,gCAAkB,SAAS,gBAAgB,GAAG;AAC/C;AAAA,MACJ;AAEA,UAAI,SAAS,GAAG;AACZ;AAAA,UACI;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,YACI,UAAM,gCAAe;AAAA,YACjB;AAAA,YACA;AAAA,YACA,YAAY;AAAA,YACZ;AAAA,UACJ,CAAC;AAAA,QACT;AACA;AAAA,MACJ;AACA,oCAAa,SAAS,OAAO,MAAM,GAAG;AACtC,oBAAc;AAEd,YAAM,UAAU,QAAQ;AAAA,QACpB,YAAY;AACR,oBAAM,gCAAe;AAAA,YACjB;AAAA,YACA;AAAA,YACA,YAAY;AAAA,YACZ;AAAA,UACJ,CAAC;AACD,cAAI,iBAAuC;AAC3C,2BAAiB,SAAS,KAAK,UAAQ,KAAK,OAAO,UAAU;AAE7D,kBAAQ,aAAa,iDAAgB,OAAO;AAC5C,qBAAW,SAAS,OAAO,UAAQ,KAAK,QAAQ,UAAU;AAE1D,kBAAQ,IAAI,MAAM,oCAAoC,KAAK,YAAY,IAAI,EAAE;AAAA,QACjF;AAAA,QACA,SAAS,OAAO,QAAQ,KAAK,CAAC;AAAA,MAClC;AAEA,UAAI,SAAS;AACT,iBAAS,KAAK,EAAE,KAAK,YAAY,QAAQ,CAAC;AAAA,MAC9C;AAAA,IACJ;AACA,WAAO;AAAA,EACX,SAAS,GAAQ;AACb,oCAAY,mBAAmB,GAAG,OAAO;AAAA,EAC7C;AACA,SAAO;AACX;",
  "names": []
}

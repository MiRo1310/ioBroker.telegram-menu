{
  "version": 3,
  "sources": ["../../src/app/getstate.ts"],
  "sourcesContent": ["import { config } from '@b/config/config';\nimport type { Part, TelegramParams } from '@b/types/types';\nimport { isParseModeFirstElement } from '@b/app/parseMode';\nimport { idBySelector } from '@b/app/idBySelector';\nimport { bindingFunc } from '@b/app/action';\nimport { isDefined } from '@b/lib/utils';\nimport { cleanUpString, decomposeText, getNewline, jsonString } from '@b/lib/string';\nimport { setTimeValue } from '@b/lib/utilities';\nimport { integrateTimeIntoText } from '@b/lib/time';\nimport { calcValue, roundValue } from '@b/lib/appUtils';\nimport { createKeyboardFromJson, createTextTableFromJson } from '@b/app/jsonTable';\nimport { sendToTelegram, sendToTelegramSubmenu } from '@b/app/telegram';\nimport { exchangeValue } from '@b/lib/exchangeValue';\nimport { errorLogger } from '@b/app/logging';\n\nexport async function getState(\n    instance: string,\n    part: Part,\n    userToSend: string,\n    telegramParams: TelegramParams,\n): Promise<void> {\n    const adapter = telegramParams.adapter;\n    try {\n        const parse_mode = isParseModeFirstElement(part);\n        const valueArrayForCorrectOrder: string[] = [];\n        const promises = (part.getData || []).map(async ({ newline, text, id }, index): Promise<void> => {\n            adapter.log.debug(`Get Value ID: ${id}`);\n\n            if (id.includes(config.functionSelektor)) {\n                await idBySelector({\n                    instance,\n                    adapter,\n                    selector: id,\n                    text,\n                    userToSend,\n                    newline,\n                    telegramParams,\n                });\n                return;\n            }\n\n            if (text.includes(config.binding.start)) {\n                await bindingFunc(adapter, instance, text, userToSend, telegramParams, parse_mode);\n                return;\n            }\n\n            const state = await adapter.getForeignStateAsync(id);\n\n            if (!isDefined(state)) {\n                adapter.log.error('The state is empty!');\n                valueArrayForCorrectOrder[index] = 'N/A';\n                return Promise.resolve();\n            }\n\n            const stateValue = cleanUpString(state.val?.toString());\n\n            let modifiedStateVal = stateValue;\n            let modifiedTextToSend = text;\n\n            if (text.includes(config.timestamp.ts) || text.includes(config.timestamp.lc)) {\n                modifiedTextToSend = await setTimeValue(adapter, text, id);\n                modifiedStateVal = '';\n            }\n\n            if (modifiedTextToSend.includes(config.time)) {\n                modifiedTextToSend = integrateTimeIntoText(modifiedTextToSend, stateValue);\n                modifiedStateVal = '';\n            }\n\n            if (modifiedTextToSend.includes(config.math.start)) {\n                const { textToSend, calculated, error } = calcValue(modifiedTextToSend, modifiedStateVal, adapter);\n                if (!error) {\n                    modifiedTextToSend = textToSend;\n                    modifiedStateVal = calculated;\n\n                    adapter.log.debug(`textToSend : ${modifiedTextToSend} val : ${modifiedStateVal}`);\n                }\n            }\n\n            if (modifiedTextToSend.includes(config.round.start)) {\n                const { error, text, roundedValue } = roundValue(String(modifiedStateVal), modifiedTextToSend);\n                if (!error) {\n                    adapter.log.debug(`Rounded from ${jsonString(modifiedStateVal)} to ${jsonString(roundedValue)}`);\n                    modifiedStateVal = roundedValue;\n                    modifiedTextToSend = text;\n                }\n            }\n\n            if (modifiedTextToSend.includes(config.json.start)) {\n                const { substring } = decomposeText(modifiedTextToSend, config.json.start, config.json.end);\n\n                if (substring.includes(config.json.textTable)) {\n                    const result = createTextTableFromJson(adapter, stateValue, modifiedTextToSend);\n                    if (result) {\n                        await sendToTelegram({\n                            instance,\n                            userToSend,\n                            textToSend: result,\n                            telegramParams,\n                            parse_mode,\n                        });\n                        return;\n                    }\n                    adapter.log.debug('Cannot create a Text-Table');\n                } else {\n                    const result = createKeyboardFromJson(adapter, stateValue, modifiedTextToSend, id, userToSend);\n                    if (stateValue && stateValue.length > 0) {\n                        if (result?.text && result?.keyboard) {\n                            sendToTelegramSubmenu(\n                                instance,\n                                userToSend,\n                                result.text,\n                                result.keyboard,\n                                telegramParams,\n                                parse_mode,\n                            );\n                        }\n                        return;\n                    }\n                    await sendToTelegram({\n                        instance,\n                        userToSend,\n                        textToSend: 'The state is empty!',\n                        telegramParams,\n                        parse_mode,\n                    });\n                    adapter.log.debug('The state is empty!');\n                    return;\n                }\n            }\n\n            const { textToSend: _text, error } = exchangeValue(adapter, modifiedTextToSend, modifiedStateVal);\n\n            const isNewline = getNewline(newline);\n            modifiedTextToSend = `${_text} ${isNewline}`;\n\n            adapter.log.debug(!error ? `Value Changed to: ${modifiedTextToSend}` : `No Change`);\n\n            valueArrayForCorrectOrder[index] = modifiedTextToSend;\n        });\n        await Promise.all(promises);\n\n        if (valueArrayForCorrectOrder.length) {\n            await sendToTelegram({\n                instance,\n                userToSend,\n                textToSend: valueArrayForCorrectOrder.join(''),\n                telegramParams,\n                parse_mode,\n            });\n        }\n    } catch (error: any) {\n        errorLogger('Error GetData:', error, adapter);\n    }\n}\n"],
  "mappings": "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",
  "names": ["error", "text"]
}

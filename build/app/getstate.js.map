{
  "version": 3,
  "sources": ["../../src/app/getstate.ts"],
  "sourcesContent": ["import { sendToTelegram, sendToTelegramSubmenu } from './telegram';\nimport { bindingFunc, calcValue, idBySelector, roundValue } from './action';\nimport { createKeyboardFromJson, createTextTableFromJson } from './jsonTable';\nimport { changeValue, processTimeIdLc } from '../lib/utilities';\nimport { decomposeText, isDefined } from './global';\nimport { _this } from '../main';\nimport type { Part, UserListWithChatId } from '../types/types';\nimport { processTimeValue } from '../lib/time';\nimport { jsonString } from '../lib/string';\n\nfunction getState(\n    part: Part,\n    userToSend: string,\n    telegramInstance: string,\n    one_time_keyboard: boolean,\n    resize_keyboard: boolean,\n    userListWithChatID: UserListWithChatId[],\n): void {\n    let text = '';\n    let i = 1;\n    // Parse Mode ist nur immer im ersten Element\n    const parse_mode = part.getData?.[0].parse_mode || 'false';\n\n    part.getData?.forEach(async element => {\n        try {\n            _this.log.debug(`Get Value ID: ${element.id}`);\n            const specifiedSelektor = 'functions=';\n            const id = element.id;\n            let textToSend = '';\n\n            if (id.indexOf(specifiedSelektor) != -1) {\n                await idBySelector(\n                    id,\n                    element.text,\n                    userToSend,\n                    element.newline,\n                    telegramInstance,\n                    one_time_keyboard,\n                    resize_keyboard,\n                    userListWithChatID,\n                );\n                return;\n            }\n\n            if (element.text.includes('binding:')) {\n                _this.log.debug('Binding');\n                await bindingFunc(\n                    element.text,\n                    userToSend,\n                    telegramInstance,\n                    one_time_keyboard,\n                    resize_keyboard,\n                    userListWithChatID,\n                    parse_mode,\n                );\n                return;\n            }\n\n            await _this.getForeignStateAsync(id).then(async (value?: ioBroker.State | null) => {\n                if (!isDefined(value)) {\n                    _this.log.error('The state is empty!');\n                    return;\n                }\n                const valueForJson: string = value.val?.toString() ?? '';\n                _this.log.debug(`State: ${jsonString(value)}`);\n\n                let val: string | number = valueForJson.replace(/\\\\/g, '').replace(/\"/g, '');\n\n                let newline = '';\n                if (element.newline === 'true') {\n                    newline = '\\n';\n                }\n                if (element.text) {\n                    textToSend = element.text.toString();\n                    if (element.text.includes('{time.lc') || element.text.includes('{time.ts')) {\n                        textToSend = (await processTimeIdLc(element.text, id)) || '';\n                        val = '';\n                    }\n                    if (textToSend.includes('{time}')) {\n                        textToSend = processTimeValue(textToSend, value);\n                        val = '';\n                    }\n                    if (textToSend.includes('math:')) {\n                        const result = calcValue(textToSend, val);\n                        if (result) {\n                            textToSend = result.textToSend;\n                            val = result.val;\n\n                            _this.log.debug(`TextToSend: ${textToSend} val: ${val}`);\n                        }\n                    }\n                    if (textToSend.includes('round:')) {\n                        const result = roundValue(val, textToSend);\n                        if (result) {\n                            _this.log.debug(\n                                `The Value was rounded ${JSON.stringify(val)} to ${JSON.stringify(result.val)}`,\n                            );\n                            val = result.val;\n                            textToSend = result.textToSend;\n                        }\n                    }\n                    if (textToSend.includes('{json')) {\n                        if (decomposeText(textToSend, '{json', '}').substring.includes('TextTable')) {\n                            const result = createTextTableFromJson(valueForJson, textToSend);\n                            if (result) {\n                                await sendToTelegram({\n                                    user: userToSend,\n                                    textToSend: result,\n                                    keyboard: undefined,\n                                    instance: telegramInstance,\n                                    resize_keyboard: one_time_keyboard,\n                                    one_time_keyboard: resize_keyboard,\n                                    userListWithChatID: userListWithChatID,\n                                    parse_mode: parse_mode,\n                                });\n                                return;\n                            }\n                            _this.log.debug('Cannot create a Text-Table');\n                        } else {\n                            const result = createKeyboardFromJson(valueForJson, textToSend, element.id, userToSend);\n                            if (valueForJson && valueForJson.length > 0) {\n                                if (result && result.text && result.keyboard) {\n                                    sendToTelegramSubmenu(\n                                        userToSend,\n                                        result.text,\n                                        result.keyboard,\n                                        telegramInstance,\n                                        userListWithChatID,\n                                        parse_mode,\n                                    );\n                                }\n                                return;\n                            }\n                            await sendToTelegram({\n                                user: userToSend,\n                                textToSend: 'The state is empty!',\n                                keyboard: undefined,\n                                instance: telegramInstance,\n                                resize_keyboard: one_time_keyboard,\n                                one_time_keyboard: resize_keyboard,\n                                userListWithChatID: userListWithChatID,\n                                parse_mode: parse_mode,\n                            });\n                            _this.log.debug('The state is empty!');\n                            return;\n                        }\n                    }\n\n                    const { val: _val, textToSend: _text, error } = changeValue(textToSend, val);\n\n                    val = _val;\n                    textToSend = _text;\n                    if (!error) {\n                        _this.log.debug(`Value Changed to: ${textToSend}`);\n                    } else {\n                        _this.log.debug(`No Change`);\n                    }\n                    if (textToSend.indexOf('&&') != -1) {\n                        text += `${textToSend.replace('&&', val.toString())}${newline}`;\n                    } else {\n                        text += `${textToSend} ${val}${newline}`;\n                    }\n                } else {\n                    text += `${val} ${newline}`;\n                }\n                _this.log.debug(`Text: ${text}`);\n\n                if (i == part.getData?.length) {\n                    if (userToSend) {\n                        await sendToTelegram({\n                            user: userToSend,\n                            textToSend: text,\n                            keyboard: undefined,\n                            instance: telegramInstance,\n                            resize_keyboard: one_time_keyboard,\n                            one_time_keyboard: resize_keyboard,\n                            userListWithChatID: userListWithChatID,\n                            parse_mode: parse_mode,\n                        });\n                    }\n                }\n                i++;\n            });\n        } catch (error: any) {\n            error({\n                array: [\n                    { text: 'Error GetData:', val: error.message },\n                    { text: 'Stack:', val: error.stack },\n                ],\n            });\n        }\n    });\n}\n\nexport { getState };\n"],
  "mappings": "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",
  "names": ["_a", "_b"]
}

{
  "version": 3,
  "sources": ["../../src/app/getstate.ts"],
  "sourcesContent": ["import { sendToTelegram, sendToTelegramSubmenu } from './telegram';\nimport { bindingFunc, idBySelector } from './action';\nimport { createKeyboardFromJson, createTextTableFromJson } from './jsonTable';\nimport { processTimeIdLc } from '../lib/utilities';\nimport { isDefined } from '../lib/utils';\nimport { adapter } from '../main';\nimport type { Part, PrimitiveType, UserListWithChatId } from '../types/types';\nimport { integrateTimeIntoText } from '../lib/time';\nimport { decomposeText, getValueToExchange, jsonString } from '../lib/string';\nimport { calcValue, roundValue } from '../lib/appUtils';\n\nfunction getState(\n    part: Part,\n    userToSend: string,\n    telegramInstance: string,\n    one_time_keyboard: boolean,\n    resize_keyboard: boolean,\n    userListWithChatID: UserListWithChatId[],\n): void {\n    let text = '';\n    let i = 1;\n    // Parse Mode ist nur immer im ersten Element\n    const parse_mode = part.getData?.[0].parse_mode;\n\n    part.getData?.forEach(async element => {\n        try {\n            adapter.log.debug(`Get Value ID: ${element.id}`);\n            const specifiedSelektor = 'functions=';\n            const id = element.id;\n            let textToSend = '';\n\n            if (id.indexOf(specifiedSelektor) != -1) {\n                await idBySelector({\n                    selector: id,\n                    text: element.text,\n                    userToSend,\n                    newline: element.newline,\n                    telegramInstance,\n                    one_time_keyboard,\n                    resize_keyboard,\n                    userListWithChatID,\n                });\n                return;\n            }\n\n            if (element.text.includes('binding:')) {\n                adapter.log.debug('Binding');\n                await bindingFunc(\n                    element.text,\n                    userToSend,\n                    telegramInstance,\n                    one_time_keyboard,\n                    resize_keyboard,\n                    userListWithChatID,\n                    parse_mode,\n                );\n                return;\n            }\n\n            await adapter.getForeignStateAsync(id).then(async (state?: ioBroker.State | null) => {\n                if (!isDefined(state)) {\n                    adapter.log.error('The state is empty!');\n                    return;\n                }\n                const valueForJson: string = state.val?.toString() ?? '';\n                adapter.log.debug(`State: ${jsonString(state)}`);\n\n                let val: PrimitiveType = valueForJson.replace(/\\\\/g, '').replace(/\"/g, '');\n\n                let newline = '';\n                if (element.newline === 'true') {\n                    newline = '\\n';\n                }\n                if (element.text) {\n                    textToSend = element.text.toString();\n                    if (element.text.includes('{time.lc') || element.text.includes('{time.ts')) {\n                        textToSend = (await processTimeIdLc(element.text, id)) || '';\n                        val = '';\n                    }\n                    if (textToSend.includes('{time}')) {\n                        textToSend = integrateTimeIntoText(textToSend, state.val);\n                        val = '';\n                    }\n                    if (textToSend.includes('math:')) {\n                        const result = calcValue(textToSend, val, adapter);\n                        if (result) {\n                            textToSend = result.textToSend;\n                            val = result.val;\n\n                            adapter.log.debug(`TextToSend: ${textToSend} val: ${val}`);\n                        }\n                    }\n                    if (textToSend.includes('round:')) {\n                        const result = roundValue(String(val), textToSend);\n                        if (result) {\n                            adapter.log.debug(\n                                `The Value was rounded ${JSON.stringify(val)} to ${JSON.stringify(result.val)}`,\n                            );\n                            val = result.val;\n                            textToSend = result.textToSend;\n                        }\n                    }\n                    if (textToSend.includes('{json')) {\n                        if (decomposeText(textToSend, '{json', '}').substring.includes('TextTable')) {\n                            const result = createTextTableFromJson(valueForJson, textToSend);\n                            if (result) {\n                                await sendToTelegram({\n                                    userToSend,\n                                    textToSend: result,\n                                    instanceTelegram: telegramInstance,\n                                    resize_keyboard,\n                                    one_time_keyboard,\n                                    userListWithChatID,\n                                    parse_mode,\n                                });\n                                return;\n                            }\n                            adapter.log.debug('Cannot create a Text-Table');\n                        } else {\n                            const result = createKeyboardFromJson(valueForJson, textToSend, element.id, userToSend);\n                            if (valueForJson && valueForJson.length > 0) {\n                                if (result && result.text && result.keyboard) {\n                                    sendToTelegramSubmenu(\n                                        userToSend,\n                                        result.text,\n                                        result.keyboard,\n                                        telegramInstance,\n                                        userListWithChatID,\n                                        parse_mode,\n                                    );\n                                }\n                                return;\n                            }\n                            await sendToTelegram({\n                                userToSend,\n                                textToSend: 'The state is empty!',\n                                instanceTelegram: telegramInstance,\n                                resize_keyboard,\n                                one_time_keyboard,\n                                userListWithChatID,\n                                parse_mode,\n                            });\n                            adapter.log.debug('The state is empty!');\n                            return;\n                        }\n                    }\n\n                    const { newValue: _val, textToSend: _text, error } = getValueToExchange(adapter, textToSend, val);\n\n                    val = _val;\n                    textToSend = _text;\n                    if (!error) {\n                        adapter.log.debug(`Value Changed to: ${textToSend}`);\n                    } else {\n                        adapter.log.debug(`No Change`);\n                    }\n                    if (textToSend.indexOf('&&') != -1) {\n                        text += `${textToSend.replace('&&', val.toString())}${newline}`;\n                    } else {\n                        text += `${textToSend} ${val}${newline}`;\n                    }\n                } else {\n                    text += `${val} ${newline}`;\n                }\n                adapter.log.debug(`Text: ${text}`);\n\n                if (i == part.getData?.length) {\n                    if (userToSend) {\n                        await sendToTelegram({\n                            userToSend,\n                            textToSend: text,\n                            instanceTelegram: telegramInstance,\n                            resize_keyboard,\n                            one_time_keyboard,\n                            userListWithChatID,\n                            parse_mode,\n                        });\n                    }\n                }\n                i++;\n            });\n        } catch (error: any) {\n            error({\n                array: [\n                    { text: 'Error GetData:', val: error.message },\n                    { text: 'Stack:', val: error.stack },\n                ],\n            });\n        }\n    });\n}\n\nexport { getState };\n"],
  "mappings": "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",
  "names": ["_a", "_b"]
}

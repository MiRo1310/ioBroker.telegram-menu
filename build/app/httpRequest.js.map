{
  "version": 3,
  "sources": ["../../src/app/httpRequest.ts"],
  "sourcesContent": ["import axios from 'axios';\nimport { sendToTelegram } from './telegram';\nimport path from 'path';\nimport fs from 'fs';\nimport { errorLogger } from './logging';\nimport type { Part, UserListWithChatId } from '../types/types';\nimport { validateDirectory } from '../lib/utils';\nimport { adapter } from '../main';\n\nasync function httpRequest(\n    parts: Part,\n    userToSend: string,\n    instanceTelegram: string,\n    resize_keyboard: boolean,\n    one_time_keyboard: boolean,\n    userListWithChatID: UserListWithChatId[],\n    directoryPicture: string,\n): Promise<boolean | undefined> {\n    if (!parts.httpRequest) {\n        return;\n    }\n    for (const part of parts.httpRequest) {\n        const { url, password, user } = part;\n\n        const method = 'get';\n        adapter.log.debug(`URL: ${url}`);\n\n        try {\n            //prettier-ignore\n            const response = await axios(\n                user && password\n                    ? {\n                        method: method,\n                        url: url,\n                        responseType: \"arraybuffer\",\n                        auth: {\n                            username: user,\n                            password: password,\n                        },\n                    }\n                    : {\n                        method: method,\n                        url: url,\n                        responseType: \"arraybuffer\",\n                    },\n            );\n            if (!part.filename) {\n                return;\n            }\n            if (!validateDirectory(adapter, directoryPicture)) {\n                return;\n            }\n            const imagePath = path.join(directoryPicture, part.filename);\n\n            fs.writeFileSync(imagePath, Buffer.from(response.data), 'binary');\n            adapter.log.debug(`Pic saved: ${imagePath}`);\n\n            await sendToTelegram({\n                userToSend,\n                textToSend: imagePath,\n                instanceTelegram,\n                resize_keyboard,\n                one_time_keyboard,\n                userListWithChatID,\n            });\n        } catch (e: any) {\n            errorLogger('Error http request:', e, adapter);\n        }\n    }\n    return true;\n}\n\nexport { httpRequest };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAkB;AAClB,sBAA+B;AAC/B,kBAAiB;AACjB,gBAAe;AACf,qBAA4B;AAE5B,mBAAkC;AAClC,kBAAwB;AAExB,eAAe,YACX,OACA,YACA,kBACA,iBACA,mBACA,oBACA,kBAC4B;AAC5B,MAAI,CAAC,MAAM,aAAa;AACpB;AAAA,EACJ;AACA,aAAW,QAAQ,MAAM,aAAa;AAClC,UAAM,EAAE,KAAK,UAAU,KAAK,IAAI;AAEhC,UAAM,SAAS;AACf,wBAAQ,IAAI,MAAM,QAAQ,GAAG,EAAE;AAE/B,QAAI;AAEA,YAAM,WAAW,UAAM,aAAAA;AAAA,QACnB,QAAQ,WACF;AAAA,UACE;AAAA,UACA;AAAA,UACA,cAAc;AAAA,UACd,MAAM;AAAA,YACF,UAAU;AAAA,YACV;AAAA,UACJ;AAAA,QACJ,IACE;AAAA,UACE;AAAA,UACA;AAAA,UACA,cAAc;AAAA,QAClB;AAAA,MACR;AACA,UAAI,CAAC,KAAK,UAAU;AAChB;AAAA,MACJ;AACA,UAAI,KAAC,gCAAkB,qBAAS,gBAAgB,GAAG;AAC/C;AAAA,MACJ;AACA,YAAM,YAAY,YAAAC,QAAK,KAAK,kBAAkB,KAAK,QAAQ;AAE3D,gBAAAC,QAAG,cAAc,WAAW,OAAO,KAAK,SAAS,IAAI,GAAG,QAAQ;AAChE,0BAAQ,IAAI,MAAM,cAAc,SAAS,EAAE;AAE3C,gBAAM,gCAAe;AAAA,QACjB;AAAA,QACA,YAAY;AAAA,QACZ;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACJ,CAAC;AAAA,IACL,SAAS,GAAQ;AACb,sCAAY,uBAAuB,GAAG,mBAAO;AAAA,IACjD;AAAA,EACJ;AACA,SAAO;AACX;",
  "names": ["axios", "path", "fs"]
}

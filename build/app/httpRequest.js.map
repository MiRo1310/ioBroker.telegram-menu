{
  "version": 3,
  "sources": ["../../src/app/httpRequest.ts"],
  "sourcesContent": ["import axios from 'axios';\nimport { sendToTelegram } from './telegram';\nimport path from 'path';\nimport fs from 'fs';\nimport { debug, errorLogger } from './logging';\nimport type { Part, UserListWithChatId } from '../types/types';\nimport { checkDirectoryIsOk } from './global';\n\nasync function httpRequest(\n    parts: Part,\n    userToSend: string,\n    instanceTelegram: string,\n    resize_keyboard: boolean,\n    one_time_keyboard: boolean,\n    userListWithChatID: UserListWithChatId[],\n    directoryPicture: string,\n): Promise<boolean | undefined> {\n    if (!parts.httpRequest) {\n        return;\n    }\n    for (const part of parts.httpRequest) {\n        const url = part.url;\n        const userName = part.user;\n        const password = part.password;\n        const method = 'get';\n        debug([{ text: 'URL:', val: url }]);\n        try {\n            //prettier-ignore\n            const response = await axios(\n                userName && password\n                    ? {\n                        method: method,\n                        url: url,\n                        responseType: \"arraybuffer\",\n                        auth: {\n                            username: userName,\n                            password: password,\n                        },\n                    }\n                    : {\n                        method: method,\n                        url: url,\n                        responseType: \"arraybuffer\",\n                    },\n            );\n            if (!part.filename) {\n                return;\n            }\n            if (!checkDirectoryIsOk(directoryPicture)) {\n                return;\n            }\n            const imagePath = path.join(directoryPicture, part.filename);\n\n            fs.writeFileSync(imagePath, Buffer.from(response.data), 'binary');\n            debug([{ text: 'Pic saved:', val: imagePath }]);\n\n            await sendToTelegram({\n                user: userToSend,\n                textToSend: imagePath,\n                instance: instanceTelegram,\n                resize_keyboard: resize_keyboard,\n                one_time_keyboard: one_time_keyboard,\n                userListWithChatID: userListWithChatID,\n                parse_mode: 'false',\n            });\n        } catch (e: any) {\n            errorLogger('Error http request:', e);\n        }\n    }\n    return true;\n}\n\nexport { httpRequest };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAkB;AAClB,sBAA+B;AAC/B,kBAAiB;AACjB,gBAAe;AACf,qBAAmC;AAEnC,oBAAmC;AAEnC,eAAe,YACX,OACA,YACA,kBACA,iBACA,mBACA,oBACA,kBAC4B;AAC5B,MAAI,CAAC,MAAM,aAAa;AACpB;AAAA,EACJ;AACA,aAAW,QAAQ,MAAM,aAAa;AAClC,UAAM,MAAM,KAAK;AACjB,UAAM,WAAW,KAAK;AACtB,UAAM,WAAW,KAAK;AACtB,UAAM,SAAS;AACf,8BAAM,CAAC,EAAE,MAAM,QAAQ,KAAK,IAAI,CAAC,CAAC;AAClC,QAAI;AAEA,YAAM,WAAW,UAAM,aAAAA;AAAA,QACnB,YAAY,WACN;AAAA,UACE;AAAA,UACA;AAAA,UACA,cAAc;AAAA,UACd,MAAM;AAAA,YACF,UAAU;AAAA,YACV;AAAA,UACJ;AAAA,QACJ,IACE;AAAA,UACE;AAAA,UACA;AAAA,UACA,cAAc;AAAA,QAClB;AAAA,MACR;AACA,UAAI,CAAC,KAAK,UAAU;AAChB;AAAA,MACJ;AACA,UAAI,KAAC,kCAAmB,gBAAgB,GAAG;AACvC;AAAA,MACJ;AACA,YAAM,YAAY,YAAAC,QAAK,KAAK,kBAAkB,KAAK,QAAQ;AAE3D,gBAAAC,QAAG,cAAc,WAAW,OAAO,KAAK,SAAS,IAAI,GAAG,QAAQ;AAChE,gCAAM,CAAC,EAAE,MAAM,cAAc,KAAK,UAAU,CAAC,CAAC;AAE9C,gBAAM,gCAAe;AAAA,QACjB,MAAM;AAAA,QACN,YAAY;AAAA,QACZ,UAAU;AAAA,QACV;AAAA,QACA;AAAA,QACA;AAAA,QACA,YAAY;AAAA,MAChB,CAAC;AAAA,IACL,SAAS,GAAQ;AACb,sCAAY,uBAAuB,CAAC;AAAA,IACxC;AAAA,EACJ;AACA,SAAO;AACX;",
  "names": ["axios", "path", "fs"]
}

{
  "version": 3,
  "sources": ["../../src/app/backMenu.ts"],
  "sourcesContent": ["import { debug, errorLogger } from './logging';\nimport type { BackMenu, NavPart, AllMenusWithData, BooleanString, Keyboard } from '../types/types';\nimport { checkStatusInfo } from '../lib/utilities';\nconst backMenu: BackMenu = {};\n\nfunction backMenuFunc(nav: string, part: NavPart, userToSend: string): void {\n    if (!part || !JSON.stringify(part).split(`\"`)[1].includes('menu:')) {\n        if (backMenu[userToSend] && backMenu[userToSend].list.length === 20) {\n            backMenu[userToSend].list.shift();\n        } else if (!backMenu[userToSend]) {\n            backMenu[userToSend] = { list: [], last: '' };\n        }\n        if (backMenu[userToSend].last !== '') {\n            backMenu[userToSend].list.push(backMenu[userToSend].last);\n        }\n        backMenu[userToSend].last = nav;\n    }\n    debug([{ text: 'GoBackMenu', val: backMenu }]);\n}\n\nasync function switchBack(\n    userToSend: string,\n    allMenusWithData: AllMenusWithData,\n    menus: string[],\n    lastMenu = false,\n): Promise<{ texttosend: string | undefined; menuToSend: Keyboard; parseMode: BooleanString } | undefined> {\n    try {\n        const list = backMenu[userToSend] && backMenu[userToSend]?.list ? backMenu[userToSend].list : [];\n        let keyboard: Keyboard = { inline_keyboard: [] };\n        let foundedMenu = '';\n        if (list.length != 0) {\n            for (const menu of menus) {\n                if (lastMenu && allMenusWithData[menu]?.[backMenu[userToSend].last]?.nav) {\n                    keyboard = allMenusWithData[menu][backMenu[userToSend].last].nav;\n                    foundedMenu = menu;\n                    break;\n                } else if (allMenusWithData[menu][list[list.length - 1]]?.nav && !lastMenu) {\n                    keyboard = allMenusWithData[menu][list[list.length - 1]].nav;\n                    debug([{ text: 'Menu call found' }]);\n                    foundedMenu = menu;\n                    break;\n                }\n                debug([{ text: 'Menu call not found in this Menu' }]);\n            }\n            if (keyboard && foundedMenu != '') {\n                let parseMode: BooleanString = '' as BooleanString;\n                if (!lastMenu) {\n                    let textToSend = allMenusWithData[foundedMenu][\n                        backMenu[userToSend].list[backMenu[userToSend].list.length - 1]\n                    ].text as string | undefined;\n                    if (textToSend) {\n                        textToSend = await checkStatusInfo(textToSend);\n                    }\n                    parseMode = (allMenusWithData[foundedMenu][\n                        backMenu[userToSend].list[backMenu[userToSend].list.length - 1]\n                    ].parse_mode || 'false') as BooleanString;\n                    backMenu[userToSend].last = list.pop();\n\n                    return { texttosend: textToSend, menuToSend: keyboard, parseMode: parseMode };\n                }\n                parseMode = (allMenusWithData[foundedMenu][backMenu[userToSend].last].parse_mode ||\n                    'false') as BooleanString;\n                return {\n                    texttosend: allMenusWithData[foundedMenu][backMenu[userToSend].last].text as string,\n                    menuToSend: keyboard,\n                    parseMode: parseMode,\n                };\n            }\n        }\n    } catch (e: any) {\n        errorLogger([\n            { text: 'Error in switchBack:', val: e.message },\n            { text: 'Stack:', val: e.stack },\n        ]);\n    }\n}\n\nexport { switchBack, backMenuFunc };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAAmC;AAEnC,uBAAgC;AAChC,MAAM,WAAqB,CAAC;AAE5B,SAAS,aAAa,KAAa,MAAe,YAA0B;AACxE,MAAI,CAAC,QAAQ,CAAC,KAAK,UAAU,IAAI,EAAE,MAAM,GAAG,EAAE,CAAC,EAAE,SAAS,OAAO,GAAG;AAChE,QAAI,SAAS,UAAU,KAAK,SAAS,UAAU,EAAE,KAAK,WAAW,IAAI;AACjE,eAAS,UAAU,EAAE,KAAK,MAAM;AAAA,IACpC,WAAW,CAAC,SAAS,UAAU,GAAG;AAC9B,eAAS,UAAU,IAAI,EAAE,MAAM,CAAC,GAAG,MAAM,GAAG;AAAA,IAChD;AACA,QAAI,SAAS,UAAU,EAAE,SAAS,IAAI;AAClC,eAAS,UAAU,EAAE,KAAK,KAAK,SAAS,UAAU,EAAE,IAAI;AAAA,IAC5D;AACA,aAAS,UAAU,EAAE,OAAO;AAAA,EAChC;AACA,4BAAM,CAAC,EAAE,MAAM,cAAc,KAAK,SAAS,CAAC,CAAC;AACjD;AAEA,eAAe,WACX,YACA,kBACA,OACA,WAAW,OAC4F;AAzB3G;AA0BI,MAAI;AACA,UAAM,OAAO,SAAS,UAAU,OAAK,cAAS,UAAU,MAAnB,mBAAsB,QAAO,SAAS,UAAU,EAAE,OAAO,CAAC;AAC/F,QAAI,WAAqB,EAAE,iBAAiB,CAAC,EAAE;AAC/C,QAAI,cAAc;AAClB,QAAI,KAAK,UAAU,GAAG;AAClB,iBAAW,QAAQ,OAAO;AACtB,YAAI,cAAY,4BAAiB,IAAI,MAArB,mBAAyB,SAAS,UAAU,EAAE,UAA9C,mBAAqD,MAAK;AACtE,qBAAW,iBAAiB,IAAI,EAAE,SAAS,UAAU,EAAE,IAAI,EAAE;AAC7D,wBAAc;AACd;AAAA,QACJ,aAAW,sBAAiB,IAAI,EAAE,KAAK,KAAK,SAAS,CAAC,CAAC,MAA5C,mBAA+C,QAAO,CAAC,UAAU;AACxE,qBAAW,iBAAiB,IAAI,EAAE,KAAK,KAAK,SAAS,CAAC,CAAC,EAAE;AACzD,oCAAM,CAAC,EAAE,MAAM,kBAAkB,CAAC,CAAC;AACnC,wBAAc;AACd;AAAA,QACJ;AACA,kCAAM,CAAC,EAAE,MAAM,mCAAmC,CAAC,CAAC;AAAA,MACxD;AACA,UAAI,YAAY,eAAe,IAAI;AAC/B,YAAI,YAA2B;AAC/B,YAAI,CAAC,UAAU;AACX,cAAI,aAAa,iBAAiB,WAAW,EACzC,SAAS,UAAU,EAAE,KAAK,SAAS,UAAU,EAAE,KAAK,SAAS,CAAC,CAClE,EAAE;AACF,cAAI,YAAY;AACZ,yBAAa,UAAM,kCAAgB,UAAU;AAAA,UACjD;AACA,sBAAa,iBAAiB,WAAW,EACrC,SAAS,UAAU,EAAE,KAAK,SAAS,UAAU,EAAE,KAAK,SAAS,CAAC,CAClE,EAAE,cAAc;AAChB,mBAAS,UAAU,EAAE,OAAO,KAAK,IAAI;AAErC,iBAAO,EAAE,YAAY,YAAY,YAAY,UAAU,UAAqB;AAAA,QAChF;AACA,oBAAa,iBAAiB,WAAW,EAAE,SAAS,UAAU,EAAE,IAAI,EAAE,cAClE;AACJ,eAAO;AAAA,UACH,YAAY,iBAAiB,WAAW,EAAE,SAAS,UAAU,EAAE,IAAI,EAAE;AAAA,UACrE,YAAY;AAAA,UACZ;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ,SAAS,GAAQ;AACb,oCAAY;AAAA,MACR,EAAE,MAAM,wBAAwB,KAAK,EAAE,QAAQ;AAAA,MAC/C,EAAE,MAAM,UAAU,KAAK,EAAE,MAAM;AAAA,IACnC,CAAC;AAAA,EACL;AACJ;",
  "names": []
}

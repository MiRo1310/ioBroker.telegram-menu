{
  "version": 3,
  "sources": ["../../src/app/action.ts"],
  "sourcesContent": ["import { sendToTelegram } from './telegram';\nimport { callSubMenu } from './subMenu';\nimport { sendNav } from './sendNav';\nimport { backMenuFunc } from './backMenu';\nimport { errorLogger } from './logging';\nimport type TelegramMenu from '../main';\n// eslint-disable-next-line no-duplicate-imports\nimport { adapter } from '../main';\n\nimport type {\n    Actions,\n    BindingObject,\n    BooleanString,\n    DataObject,\n    GenerateActionsNewObject,\n    MenuData,\n    NewObjectStructure,\n    Part,\n    Switch,\n    TelegramParams,\n    UserListWithChatId,\n    UserObjectActions,\n    UsersInGroup,\n} from '../types/types';\nimport { decomposeText, getNewline } from '../lib/string';\nimport { isFalsy, isTruthy } from '../lib/utils';\nimport { evaluate } from '../lib/math';\nimport { arrayOfEntries, config } from '../config/config';\nimport { getBindingValues } from '../lib/splitValues';\nimport { exchangeValue } from '../lib/exchangeValue';\n\nconst bindingFunc = async (\n    text: string,\n    userToSend: string,\n    telegramParams: TelegramParams,\n    parse_mode?: boolean,\n): Promise<void> => {\n    let textToSend;\n\n    try {\n        const { substringExcludeSearch } = decomposeText(text, config.binding.start, config.binding.end);\n        const arrayOfItems = substringExcludeSearch.split(config.binding.splitChar);\n        const bindingObject: BindingObject = {\n            values: {},\n        };\n\n        for (let item of arrayOfItems) {\n            if (!item.includes('?')) {\n                const { key, id } = getBindingValues(item);\n                if (id) {\n                    const result = await adapter.getForeignStateAsync(id);\n\n                    if (result) {\n                        bindingObject.values[key] = result.val?.toString() ?? '';\n                    }\n                }\n            } else {\n                Object.keys(bindingObject.values).forEach(function (key) {\n                    item = item.replace(key, bindingObject.values[key]);\n                });\n\n                const { val } = evaluate(item, adapter);\n                textToSend = String(val);\n            }\n        }\n        await sendToTelegram({\n            userToSend,\n            textToSend,\n            telegramParams,\n            parse_mode,\n        });\n    } catch (e: any) {\n        errorLogger('Error Binding function: ', e, adapter);\n    }\n};\n\nfunction getCommonName({ name, adapter }: { name?: ioBroker.StringOrTranslated; adapter: TelegramMenu }): string {\n    const language = adapter.language ?? 'en';\n    if (!name) {\n        return '';\n    }\n    if (typeof name === 'string') {\n        return name;\n    }\n    if (language) {\n        return name[language] ?? '';\n    }\n    return '';\n}\n\nfunction removeLastPartOfId(id: string): string {\n    const parts = id.split('.');\n    parts.pop();\n    return parts.join('.');\n}\n\nconst idBySelector = async ({\n    selector,\n    text,\n    userToSend,\n    newline,\n    telegramParams,\n}: {\n    selector: string;\n    text: string;\n    userToSend: string;\n    newline: BooleanString;\n    telegramParams: TelegramParams;\n}): Promise<void> => {\n    let text2Send = '';\n    try {\n        const functions = selector.replace(config.functionSelektor, '');\n        let enums: string[] | undefined = [];\n        const result = await adapter.getEnumsAsync();\n        const enumsFunctions = result?.['enum.functions'][`enum.functions.${functions}`];\n        if (!enumsFunctions) {\n            return;\n        }\n        enums = enumsFunctions.common.members;\n        if (!enums) {\n            return;\n        }\n\n        const promises = enums.map(async (id: string) => {\n            const value = await adapter.getForeignStateAsync(id);\n\n            let newText = text;\n\n            if (text.includes('{common.name}')) {\n                const result = await adapter.getForeignObjectAsync(id);\n                newText = newText.replace('{common.name}', getCommonName({ name: result?.common.name, adapter }));\n            }\n            if (text.includes('{folder.name}')) {\n                const result = await adapter.getForeignObjectAsync(removeLastPartOfId(id));\n                newText = newText.replace('{folder.name}', getCommonName({ name: result?.common.name, adapter }));\n            }\n\n            const { textToSend } = exchangeValue(adapter, newText, value?.val ?? '');\n\n            text2Send += textToSend;\n            text2Send += getNewline(newline);\n\n            adapter.log.debug(`Text to send:  ${JSON.stringify(text2Send)}`);\n        });\n        Promise.all(promises)\n            .then(async () => {\n                await sendToTelegram({\n                    userToSend,\n                    textToSend: text2Send,\n                    telegramParams,\n                });\n            })\n            .catch(e => {\n                errorLogger('Error Promise', e, adapter);\n            });\n    } catch (error: any) {\n        errorLogger('Error idBySelector', error, adapter);\n    }\n};\n\nfunction generateActions({\n    action,\n    userObject,\n}: {\n    action?: Actions;\n    userObject: NewObjectStructure;\n}): { obj: NewObjectStructure; ids: string[] } | undefined {\n    try {\n        const listOfSetStateIds: string[] = [];\n        action?.set.forEach(function (\n            { trigger, switch_checkbox, returnText, parse_mode, values, confirm, ack, IDs },\n            index,\n        ) {\n            const triggerName = trigger[0];\n            if (index == 0) {\n                userObject[triggerName] = { switch: [] };\n            }\n            userObject[triggerName] = { switch: [] };\n\n            IDs.forEach(function (id: string, index: number) {\n                listOfSetStateIds.push(id);\n                const toggle = isTruthy(switch_checkbox[index]);\n\n                const newObj: Switch = {\n                    id: IDs[index],\n                    value: values[index],\n                    toggle: toggle,\n                    confirm: confirm[index],\n                    returnText: returnText[index],\n                    ack: isTruthy(ack?.[index] ?? false),\n                    parse_mode: isTruthy(parse_mode[0]),\n                };\n                if (Array.isArray(userObject[triggerName]?.switch)) {\n                    userObject[triggerName].switch.push(newObj);\n                }\n            });\n        });\n\n        arrayOfEntries.forEach(item => {\n            const actions = action?.[item.objName as keyof Actions];\n\n            actions?.forEach(function (element, index) {\n                const trigger = element.trigger[0];\n                userObject[trigger] = { [item.name]: [] };\n                if (index == 0) {\n                    userObject[trigger] = { [item.name as keyof UserObjectActions]: [] };\n                }\n\n                (element[item.loop as keyof typeof element] as string[]).forEach(function (id, index) {\n                    const newObj = {} as GenerateActionsNewObject;\n                    item.elements.forEach(({ name, value, index: elIndex }) => {\n                        const elName = (value ? value : name) as keyof typeof element;\n                        const newIndex = elIndex ? elIndex : index;\n\n                        const val = !element[elName] ? false : element[elName][newIndex] || 'false';\n\n                        if (name === 'parse_mode') {\n                            newObj.parse_mode = isTruthy(val);\n                        }\n\n                        if (typeof val === 'string') {\n                            newObj[name as keyof GenerateActionsNewObject] = val.replace(/&amp;/g, '&') as any;\n                        }\n                    });\n\n                    (userObject?.[trigger]?.[item.name as keyof Part] as GenerateActionsNewObject[]).push(newObj);\n                });\n            });\n        });\n\n        return { obj: userObject, ids: listOfSetStateIds };\n    } catch (err: any) {\n        errorLogger('Error generateActions:', err, adapter);\n    }\n}\n\nconst adjustValueType = (value: keyof NewObjectStructure, valueType: string): boolean | string | number => {\n    if (valueType == 'number') {\n        if (!parseFloat(value)) {\n            adapter.log.error(`Error: Value is not a number: ${value}`);\n            return false;\n        }\n        return parseFloat(value);\n    }\n    if (valueType == 'boolean') {\n        return isTruthy(value);\n    }\n    return value;\n};\n\nexport const checkEvent = async (\n    dataObject: DataObject,\n    id: string,\n    state: ioBroker.State,\n    menuData: MenuData,\n    telegramParams: TelegramParams,\n    usersInGroup: UsersInGroup,\n): Promise<boolean> => {\n    const menuArray: string[] = [];\n    let ok = false;\n    let calledNav = '';\n\n    if (!dataObject.action) {\n        return false;\n    }\n\n    Object.keys(dataObject.action).forEach(menu => {\n        if (dataObject.action?.[menu]?.events) {\n            dataObject.action[menu].events.forEach(event => {\n                if (event.ID[0] == id && event.ack[0] == state.ack.toString()) {\n                    const condition = event.condition[0];\n                    if (\n                        ((state.val == true || state.val == 'true') && isTruthy(condition)) ||\n                        ((state.val == false || state.val == 'false') && isFalsy(condition)) ||\n                        (typeof state.val == 'number' && state.val == parseInt(condition)) ||\n                        state.val == condition\n                    ) {\n                        ok = true;\n                        menuArray.push(menu);\n                        calledNav = event.menu[0];\n                    }\n                }\n            });\n        }\n    });\n    if (!ok || !menuArray.length) {\n        return false;\n    }\n\n    for (const menu of menuArray) {\n        const part = menuData[menu][calledNav as keyof DataObject];\n        if (usersInGroup[menu] && part) {\n            for (const user of usersInGroup[menu]) {\n                const menus = Object.keys(menuData);\n\n                if (part.nav) {\n                    backMenuFunc({ activePage: calledNav, navigation: part.nav, userToSend: user });\n                }\n\n                if (part?.nav?.[0][0].includes('menu:')) {\n                    await callSubMenu({\n                        jsonStringNav: part.nav[0][0],\n                        userToSend: user,\n                        telegramParams: telegramParams,\n                        part: part,\n                        allMenusWithData: menuData,\n                        menus: menus,\n                    });\n                    return true;\n                }\n                await sendNav(part, user, telegramParams);\n            }\n        }\n    }\n    return true;\n};\n\nexport const getUserToSendFromUserListWithChatID = (\n    userListWithChatID: UserListWithChatId[],\n    chatID: string,\n): string | undefined => {\n    for (const element of userListWithChatID) {\n        if (element.chatID == chatID) {\n            return element.name;\n        }\n    }\n};\n\nexport { idBySelector, generateActions, bindingFunc, adjustValueType };\n"],
  "mappings": "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",
  "names": ["adapter", "result", "index", "_a"]
}

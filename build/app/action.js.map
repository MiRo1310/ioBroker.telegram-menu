{
  "version": 3,
  "sources": ["../../src/app/action.ts"],
  "sourcesContent": ["import type {\n    Actions,\n    Adapter,\n    BindingObject,\n    DataObject,\n    GenerateActionsNewObject,\n    MenuData,\n    NewObjectStructure,\n    Part,\n    Switch,\n    TelegramParams,\n    UserObjectActions,\n} from '@b/types/types';\nimport { decomposeText } from '@b/lib/string';\nimport { arrayOfEntries, config } from '@b/config/config';\nimport { getBindingValues } from '@b/lib/splitValues';\nimport { evaluate } from '@b/lib/math';\nimport { sendToTelegram } from '@b/app/telegram';\nimport { errorLogger } from '@b/app/logging';\nimport { isTruthy } from '@b/lib/utils';\nimport type { MenusWithUsers, TriggerableActions, UserListWithChatID } from '@/types/app';\nimport { backMenuFunc } from '@b/app/backMenu';\nimport { callSubMenu } from '@b/app/subMenu';\nimport { sendNav } from '@b/app/sendNav';\n\nexport const bindingFunc = async (\n    adapter: Adapter,\n    instance: string,\n    text: string,\n    userToSend: string,\n    telegramParams: TelegramParams,\n    parse_mode?: boolean,\n): Promise<void> => {\n    let textToSend;\n\n    try {\n        const { substringExcludeSearch } = decomposeText(text, config.binding.start, config.binding.end);\n        const arrayOfItems = substringExcludeSearch.split(config.binding.splitChar);\n        const bindingObject: BindingObject = {\n            values: {},\n        };\n\n        for (let item of arrayOfItems) {\n            if (!item.includes('?')) {\n                const { key, id } = getBindingValues(item);\n                if (id) {\n                    const result = await adapter.getForeignStateAsync(id);\n\n                    if (result) {\n                        bindingObject.values[key] = result.val?.toString() ?? '';\n                    }\n                }\n            } else {\n                Object.keys(bindingObject.values).forEach(function (key) {\n                    item = item.replace(key, bindingObject.values[key]);\n                });\n\n                const { val } = evaluate(item, adapter);\n                textToSend = String(val);\n            }\n        }\n        await sendToTelegram({\n            instance,\n            userToSend,\n            textToSend,\n            telegramParams,\n            parse_mode,\n        });\n    } catch (e: any) {\n        errorLogger('Error Binding function: ', e, adapter);\n    }\n};\n\nexport function generateActions({\n    action,\n    userObject,\n    adapter,\n}: {\n    action?: Actions;\n    userObject: NewObjectStructure;\n    adapter: Adapter;\n}): { obj: NewObjectStructure; ids: string[] } | undefined {\n    try {\n        const listOfSetStateIds: string[] = [];\n        action?.set.forEach(function (\n            { trigger, switch_checkbox, returnText, parse_mode, values, confirm, ack, IDs },\n            index,\n        ) {\n            const triggerName = trigger[0];\n            if (index == 0) {\n                userObject[triggerName] = { switch: [] };\n            }\n            userObject[triggerName] = { switch: [] };\n\n            IDs.forEach(function (id: string, index: number) {\n                listOfSetStateIds.push(id);\n                const toggle = isTruthy(switch_checkbox[index]);\n\n                const newObj: Switch = {\n                    id: IDs[index],\n                    value: values[index],\n                    toggle: toggle,\n                    confirm: confirm[index],\n                    returnText: returnText[index],\n                    ack: ack?.length ? isTruthy(ack[index]) : false,\n                    parse_mode: parse_mode?.length ? isTruthy(parse_mode?.[0]) : false,\n                };\n                if (Array.isArray(userObject?.[triggerName]?.switch)) {\n                    userObject[triggerName].switch?.push(newObj);\n                }\n            });\n        });\n\n        arrayOfEntries.forEach(item => {\n            const actions = action?.[item.objName as keyof Actions];\n\n            actions?.forEach(function (element, index) {\n                const trigger = (element as TriggerableActions)?.trigger[0];\n                userObject[trigger] = { [item.name]: [] };\n                if (index == 0) {\n                    userObject[trigger] = { [item.name as keyof UserObjectActions]: [] };\n                }\n\n                (element[item.loop as keyof typeof element] as []).forEach(function (id, index) {\n                    const newObj = {} as GenerateActionsNewObject;\n                    item.elements.forEach(({ name, value, index: elIndex }) => {\n                        const elName = (value ? value : name) as keyof typeof element;\n                        const newIndex = elIndex ? elIndex : index;\n\n                        const val = !element[elName] ? false : (element[elName][newIndex] ?? 'false');\n\n                        if (name === 'parse_mode') {\n                            newObj.parse_mode = isTruthy(val);\n                        }\n\n                        if (typeof val === 'string') {\n                            newObj[name as keyof GenerateActionsNewObject] = String(val).replace(/&amp;/g, '&') as any;\n                        }\n                    });\n\n                    (userObject?.[trigger]?.[item.name as keyof Part] as GenerateActionsNewObject[]).push(newObj);\n                });\n            });\n        });\n\n        return { obj: userObject, ids: listOfSetStateIds };\n    } catch (err: any) {\n        errorLogger('Error generateActions:', err, adapter);\n    }\n}\n\nexport const adjustValueType = (\n    adapter: Adapter,\n    value: keyof NewObjectStructure,\n    valueType: string,\n): boolean | string | number => {\n    if (valueType == 'number') {\n        if (!parseFloat(value)) {\n            adapter.log.error(`Error: Value is not a number: ${value}`);\n            return false;\n        }\n        return parseFloat(value);\n    }\n    if (valueType == 'boolean') {\n        return isTruthy(value);\n    }\n    return value;\n};\n\nconst toBoolean = (value: string): boolean | null => {\n    if (value === 'true') {\n        return true;\n    }\n    if (value === 'false') {\n        return false;\n    }\n    return null;\n};\n\nexport const handleEvent = async (\n    adapter: Adapter,\n    instance: string,\n    dataObject: DataObject,\n    id: string,\n    state: ioBroker.State,\n    menuData: MenuData,\n    telegramParams: TelegramParams,\n    usersInGroup: MenusWithUsers,\n): Promise<boolean> => {\n    const menuArray: string[] = [];\n    let ok = false;\n    let calledNav = '';\n\n    if (!dataObject.action) {\n        return false;\n    }\n\n    Object.keys(dataObject.action).forEach(menu => {\n        if (dataObject.action?.[menu]?.events) {\n            dataObject.action[menu]?.events.forEach(event => {\n                if (event.ID[0] == id && event.ack[0] == state.ack.toString()) {\n                    const condition = event.condition[0];\n                    const bool = toBoolean(condition);\n                    if (\n                        bool\n                            ? state.val === bool\n                            : (typeof state.val == 'number' &&\n                                  (state.val == parseInt(condition) || state.val == parseFloat(condition))) ||\n                              state.val == condition\n                    ) {\n                        ok = true;\n                        menuArray.push(menu);\n                        calledNav = event.menu[0];\n                    }\n                }\n            });\n        }\n    });\n    if (!ok || !menuArray.length) {\n        return false;\n    }\n\n    for (const menu of menuArray) {\n        const part = menuData[menu][calledNav as keyof DataObject];\n        const menuValue = usersInGroup[menu];\n        if (menuValue && part) {\n            for (const user of menuValue) {\n                const menus = Object.keys(menuData);\n\n                if (part.nav) {\n                    backMenuFunc({ activePage: calledNav, navigation: part.nav, userToSend: user.name });\n                }\n\n                if (part?.nav?.[0][0].includes('menu:')) {\n                    await callSubMenu({\n                        adapter,\n                        instance,\n                        jsonStringNav: part.nav[0][0],\n                        userToSend: user.name,\n                        telegramParams: telegramParams,\n                        part,\n                        allMenusWithData: menuData,\n                        menus,\n                    });\n                    return true;\n                }\n                await sendNav(adapter, instance, part, user.name, telegramParams);\n            }\n        }\n    }\n    return true;\n};\n\nexport const getUserToSendFromUserListWithChatID = (\n    userListWithChatID: UserListWithChatID[],\n    chatID: string,\n): UserListWithChatID | undefined => {\n    for (const element of userListWithChatID) {\n        if (element.chatID == chatID) {\n            return element;\n        }\n    }\n};\n"],
  "mappings": "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",
  "names": ["index", "_a"]
}

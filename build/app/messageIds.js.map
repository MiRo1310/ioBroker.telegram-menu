{
  "version": 3,
  "sources": ["../../src/app/messageIds.ts"],
  "sourcesContent": ["import TelegramMenu from '../main';\nimport { deleteMessageByBot } from './botAction';\nimport { errorLogger } from './logging';\nimport type { UserListWithChatId, WhatShouldDelete } from '../types/types';\nimport { deepCopy } from './global';\nimport { getChatID } from '../lib/utils';\n\ninterface Messages {\n    [key: string]: MessageInfos[];\n}\ninterface MessageInfos {\n    id: ioBroker.StateValue;\n    time?: number;\n    request?: ioBroker.StateValue | null | undefined;\n}\nlet isDeleting = false;\nasync function saveMessageIds(state: ioBroker.State, instanceTelegram: string): Promise<void> {\n    const _this = TelegramMenu.getInstance();\n    try {\n        let requestMessageId: Messages = {};\n        let requestMessageIdObj: ioBroker.State | null | undefined = null;\n        if (!isDeleting) {\n            requestMessageIdObj = await _this.getStateAsync('communication.requestIds');\n        }\n        isDeleting = false;\n        const requestUserIdObj = await _this.getForeignStateAsync(`${instanceTelegram}.communicate.requestChatId`);\n\n        const request = await _this.getForeignStateAsync(`${instanceTelegram}.communicate.request`);\n\n        if (!(requestUserIdObj && requestUserIdObj.val)) {\n            return;\n        }\n\n        requestMessageId = requestMessageIdObj?.val ? JSON.parse(requestMessageIdObj?.val.toString()) : {};\n\n        if (!requestMessageId[requestUserIdObj.val.toString()]) {\n            requestMessageId[requestUserIdObj.val.toString()] = [];\n        }\n\n        if (!requestMessageId[requestUserIdObj.val.toString()]?.find(message => message.id === state.val)) {\n            requestMessageId[requestUserIdObj.val.toString()].push({\n                id: state.val,\n                time: Date.now(),\n                request: request?.val,\n            });\n        }\n\n        requestMessageId = removeOldMessageIds(requestMessageId, requestUserIdObj.val.toString());\n        await _this.setState('communication.requestIds', JSON.stringify(requestMessageId), true);\n    } catch (e: any) {\n        errorLogger([\n            { text: 'Error saveMessageIds:', val: e.message },\n            { text: 'Stack:', val: e.stack },\n        ]);\n    }\n}\nfunction removeOldMessageIds(messages: Messages, chatID: string): Messages {\n    messages[chatID] = messages[chatID].filter(message => {\n        return message.time && message.time > Date.now() - 1000 * 60 * 60 * 24 * 2;\n    });\n    return messages;\n}\n\nconst removeMessageFromList = ({\n    element,\n    chat_id,\n    copyMessageIds,\n}: {\n    element: any;\n    chat_id: string;\n    copyMessageIds: Messages;\n}): MessageInfos[] => {\n    return copyMessageIds[chat_id].filter(message => message.id !== element.id);\n};\n\nasync function deleteMessageIds(\n    user: string,\n    userListWithChatID: UserListWithChatId[],\n    instanceTelegram: string,\n    whatShouldDelete: WhatShouldDelete,\n): Promise<void> {\n    const _this = TelegramMenu.getInstance();\n    try {\n        const requestMessageIdObj = await _this.getStateAsync('communication.requestIds');\n        const lastMessageId = await _this.getForeignStateAsync(`${instanceTelegram}.communicate.requestMessageId`);\n\n        if (\n            !requestMessageIdObj ||\n            typeof requestMessageIdObj.val !== 'string' ||\n            !JSON.parse(requestMessageIdObj.val)\n        ) {\n            return;\n        }\n\n        const chat_id = getChatID(userListWithChatID, user);\n        if (!chat_id) {\n            return;\n        }\n        const messageIds: Messages = JSON.parse(requestMessageIdObj.val);\n\n        if (lastMessageId && lastMessageId.val) {\n            messageIds[chat_id].push({ id: lastMessageId.val.toString() });\n        }\n\n        isDeleting = true;\n        const copyMessageIds = deepCopy(messageIds);\n        messageIds[chat_id].forEach((element, index) => {\n            if (whatShouldDelete === 'all' && element.id) {\n                deleteMessageByBot(\n                    instanceTelegram,\n                    user,\n                    userListWithChatID,\n                    parseInt(element.id?.toString()),\n                    chat_id,\n                );\n            }\n            if (whatShouldDelete === 'last' && index === messageIds[chat_id].length - 1 && element.id) {\n                deleteMessageByBot(\n                    instanceTelegram,\n                    user,\n                    userListWithChatID,\n                    parseInt(element.id?.toString()),\n                    chat_id,\n                );\n            }\n            if (!copyMessageIds) {\n                return;\n            }\n            copyMessageIds[chat_id] = removeMessageFromList({ element, chat_id, copyMessageIds });\n        });\n\n        await _this.setState('communication.requestIds', JSON.stringify(copyMessageIds), true);\n    } catch (e: any) {\n        errorLogger([\n            { text: 'Error deleteMessageIds:', val: e.message },\n            { text: 'Stack:', val: e.stack },\n        ]);\n    }\n}\n\nexport { deleteMessageIds, saveMessageIds };\n"],
  "mappings": "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",
  "names": ["TelegramMenu"]
}
